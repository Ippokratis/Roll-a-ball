<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Roll-a-ball by Ippokratis</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Roll-a-ball</h1>
      <h2 class="project-tagline">roll-a-ball unity3d written tutorial</h2>
      <a href="https://github.com/Ippokratis/Roll-a-ball" class="btn">View on GitHub</a>
      <a href="https://github.com/Ippokratis/Roll-a-ball/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/Ippokratis/Roll-a-ball/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="introduction-to-roll-a-ball" class="anchor" href="#introduction-to-roll-a-ball" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>INTRODUCTION TO ROLL-A-BALL</strong>
</h1>

<p>In this beginner assignment we are going
to make a very simple but playable game to
use many of the basic concepts from the
beginner tutorial modules.</p>

<p>We will be making a roll-a-ball game where
we will collect special game objects.</p>

<p>We will see how to create new game objects,
add components to these game objects,
set the values on their properties and position
these game objects in the scene to create a game.</p>

<p>In our game the player will control a ball
rolling around the game board.
We will move the ball using physics and forces.
We will look at the input from the player
through the keyboard and we'll use those
inputs to apply forces to the ball, making it
move in our scene.</p>

<p>We will see how to detect contact between
the player's ball and the pick-up game objects,
and use these events to collect these
pick-up game objects.</p>

<p>When we are done we will have made a simple
roll-a-ball game where the player controls
the ball with the keyboard, picks up and
counts special collectable objects,
displays the current count and ends the game
when all of the game objects
have been picked up.</p>

<p>We won't need to import any assets for this project.</p>

<p>We won't be using models, textures,
sounds or animations for this assignment.</p>

<p>We will simply use the primitive shapes
like cubes, spheres and planes
provided by Unity.</p>

<p>To begin, start with assignment 1 where we
setup our game and starting game objects.</p>

<h1>
<a id="setting-up-the-game" class="anchor" href="#setting-up-the-game" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>SETTING UP THE GAME</strong>
</h1>

<p>Let's begin by creating a new project.</p>

<p>We can create a new project from File - New Project.
This will bring up the home screen.</p>

<p>I'm going to call the new project Roll a Ball.</p>

<p>The next thing we need to do is set the destination,
or path to our new project.</p>

<p>I'm going to put this new project on my desktop.
At this point it's worth noting that we can
have our new project use default settings
for either a 2D project or a 3D project.</p>

<p>We will choose 3D.</p>

<p>And then I will click on Create Project
to make a new project.</p>

<p>We now have our new project with a new empty scene.</p>

<p>Before creating anything in the new scene
we need to save our scene.</p>

<p>We can save our scene by going to File - Save Scene
or by using the keyboard shortcut.</p>

<p>I'm going to save this scene in the Assets directory
in a new folder called _scenes.</p>

<p>The underscore is optional, I use it to sort this
folder to the top of my project window.</p>

<p>Now I'm going to call the scene MiniGame.
We can now see in our Scenes folder
the scene called MiniGame.</p>

<p>Let's create our game board, or play field.</p>

<p>To do this we will use a stock Unity plane.</p>

<p>We can create this plane from either
Game Object - 3D Object - Plane.</p>

<p>Or from inside the Hierarchy view using the Create menu.</p>

<p>Rename this game object Ground.
We can do this by either selecting the game object
and using the enter or return keys
to allow editing, or by clicking on the
game object twice, slowly.</p>

<p>Type in the new name or hit enter or return
to confirm this change.</p>

<p>Reset the transform component using the context
sensitive gear menu in the upper right.</p>

<p>This will place the game object at the location of
(0, 0, 0) in our scene.</p>

<p>This point is known as the origin point
of the world and this is where all of the
coordinates in the scene are calculated from.</p>

<p>Now with the game object selected and the
cursor over the Scene view type the F key, or choose
Frame Selected from the Edit menu
to see the entire game object in the Scene view.</p>

<p>Looking at our current scene,
we can see grid lines indicating the plane at origin.</p>

<p>For the purposes of this project
we will turn them off.</p>

<p>Select the Gizmos menu in the Scene view
and deselect Show Grid.</p>

<p>We need to change the scale of the ground plane.</p>

<p>We can do this in a number of ways..</p>

<p>We can use the Scale tool,
simply grab the axis handle you want to change
and drag the handle rescaling the plane.</p>

<p>We can click and drag on the title of
the fields we want to change.</p>

<p>Or we can type a number directly in to the
field we want to change.</p>

<p>You can tab between fields and hit enter or return
to confirm your choice.</p>

<p>Now remember a plane has no volume
and scale does not work on the Y axis.</p>

<p>There will be no change unless you go in to negative numbers.</p>

<p>In this case the plane, which is a single
sided object will simply face the other direction.</p>

<p>If you place a plane in the scene and you can't see it
check your orientation between the plane and camera
and make sure that you have the correct values
for the Y axis of scale.</p>

<p>This is usually the value of 1.</p>

<p>Let's create our player object.</p>

<p>In this assignment our player object
will be a Unity sphere.</p>

<p>From the Hierarchy - Create menu select Sphere.</p>

<p>Rename the sphere Player.</p>

<p>Reset the transform to make sure it's a origin.</p>

<p>Select Edit - Frame Selected
or use the F key while the cursor is
over the Scene view to focus our Scene view
camera on our game object.</p>

<p>See how the sphere is buried in the plane?</p>

<p>This is because both game objects
are in the exact same location in the scene,
the origin point, or (0, 0, 0)</p>

<p>on the X, Y and Z axis.
We need to move the player's sphere up
until it rests on the plane.</p>

<p>All Unity primitive objects, cubes, spheres, capsules,
have a standard size, they are either
1 by 1 by 1 or 1 by 2 by 1 Unity units.</p>

<p>As such we simply lift the player object up
by half a unit in the Y axis
and we know it is laying perfectly on top of plane.
If we look in the Game view we can that the
player game object is lit and it
casts a shadow on the plane.</p>

<p>All new Unity scenes come with the
default sky box and a directional light
to represent the sun, so we don't need to worry
about setting up any default lighting.</p>

<p>What could be improved however is the
white player sphere on the white background.
Let's add some colour to our background
so there is some contrast between the player and the play field.</p>

<p>To add colour or texture to a model
we need to use a material.</p>

<p>We won't go in to the details of materials now,
and we won't be using any textures.</p>

<p>We will simply use a standard material
to add colour to the objects in our scene.</p>

<p>First let's create a new folder in our
project to hold our materials.</p>

<p>We can do this by using the project's
Create menu and selecting Folder.</p>

<p>Rename this folder Material.</p>

<p>With the Materials folder selected
use the project's Create menu again
and this time select Material.</p>

<p>Note how the material was created in the Materials folder.</p>

<p>This is because we had the folder selected
when we chose to create our new material</p>

<p>Rename this material Background.</p>

<p>Select the material and under Main Maps
the first property is Albido.</p>

<p>Click on the Albido's colour field
to open a colour picker.</p>

<p>Change the colour to a nice dark shade of blue.</p>

<p>In our case I will use the RGB values of 0, 32, 64.</p>

<p>For a preview of the material make sure
that the preview window is open.</p>

<p>To apply the texture to the plane,
simply select the material in the project view
and drag it on to the plane in the scene view.</p>

<p>Now the player stands out on the dark blue background.</p>

<p>I want to make one additional change that
will help us later in this project.</p>

<p>I want to rotate the main directional light
so that we have better lighting on our player.</p>

<p>Select the directional light and in the transform component
change the Transform Rotation on the Y axis to 60.</p>

<p>This will give better shape to our player sphere.</p>

<p>Now we have a player game object and a background play field.</p>

<h1>
<a id="moving-the-player" class="anchor" href="#moving-the-player" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>MOVING THE PLAYER</strong>
</h1>

<p>Now we are going to move the player game object.</p>

<p>First let's think through how we want this player
game object to behave.</p>

<p>We want to have the sphere roll around on the
game area, bump in to walls, stay on the ground
and not fly off in to space.</p>

<p>We want to be able to collide with our collectible
game objects and pick them up when we do.</p>

<p>This requires physics.</p>

<p>To use physics the game object needs
a rigidbody component attached.</p>

<p>To attach a new component we must first
select the game object we want to attach
the component to, in this case we will select
our player game object.</p>

<p>Then we can either choose the Component menu
and select Physics - Rigid Body
which would attach this component to the game object
we have selected.</p>

<p>Or use the Add Component button in the Inspector
choosing Physics - Rigid Body.</p>

<p>Either way this attached the rigidbody
component to the selected game object.</p>

<p>If we choose to we can rearrange the
order of the components on the game object
using the context sensitive gear menu
in the upper right of the component.</p>

<p>Doing this has no effect on the performance of our game.</p>

<p>However, having a consistent order to the components
on our game object may help us speed up our development
by keeping or maintaining an organised
project and hierarchy.</p>

<p>Don't forget, you can collapse or expand
the Component view by clicking on the component's title bar.</p>

<p>We should note that whenever we do this
this will also toggle the relevant
gizmos for that component in the Scene view.</p>

<p>Now we need to get the player object moving
under our control.</p>

<p>To do this we need to get input from our player
through the keyboard and we need to apply
that input to the player game object as forces
to move the sphere in the scene.</p>

<p>We will do this by using a script that
we attach to the player game object.</p>

<p>First let's create a folder in our project view
to hold our script assets.</p>

<p>In the Project view click on the Create menu
and choose Create Folder.</p>

<p>Rename this folder Scripts.</p>

<p>Next let's create a new C# script.</p>

<p>To create a new script we have some choices.</p>

<p>We can choose Assets - Create
to create our new C# script.</p>

<p>Or we can use the Create menu in the project view.</p>

<p>But what might be more efficient in this case
would be to select the player game object
and use the Add Component button in the Inspector.</p>

<p>The Add Component menu contains the selection
New Script.</p>

<p>This allows us to both create and attach
a script in one step.</p>

<p>First let's name this script PlayerController.</p>

<p>We can choose the language of the script, which will be C#,
and then click on Create and Add.</p>

<p>Or simply hit the return or enter key to
confirm our selection.</p>

<p>Unity will create, compile and attach this script
to our selected game object.</p>

<p>We should note, this way of creating a script
will create that script asset on the root
or top level of our Project view.</p>

<p>We will need to move the asset in to the Scripts directory
in order to maintain an organised Project view.</p>

<p>If we select the script in our Project view
we see a preview of the script asset in the Inspector,
but this text is not editable.</p>

<p>Let's open the script.</p>

<p>We can do this a number of ways.</p>

<p>When we are inspecting a game object using the script
we can use the context sensitive gear menu.</p>

<p>We can double click on the script asset in the Project view
or we can use the Open button in the Inspector
when we have the script selected in our Project view.</p>

<p>This will open our script in our preferred script editor.</p>

<p>First let's remove the sample code provided
in the base script.</p>

<p>Next let's think,
what do we want to do with this script?
We want to check every frame for player input
and then we want to apply that input to the
player game object every frame as movement.</p>

<p>Where will we check for and apply this input?
We have two choices.</p>

<p>Update and Fixed Update.</p>

<p>Update is called before rendering a frame
and this is where most of our game code will go.</p>

<p>Fixed Update on the other hand is called just
before performing any physics calculations
and this is where our physics code will go.</p>

<p>We will be moving our ball by applying forces
to the rigidbody, this is physics.</p>

<p>So we will put our code in Fixed Update.</p>

<p>What code to we need to write?
We know we need input,
but how do we find out more?
There is a shortcut in Monodevelop
that searches the Unity API.</p>

<p>On the mac it's command plus single quote,
and on the pc it's control plus single quote.</p>

<p>Select the item you want to research,
in our case input,
and hold down the command or control key and
type the single quote button.</p>

<p>This search brings up every reference
in our documentation related to input.</p>

<p>Select Input at the top,
interface in to the input system.</p>

<p>This brings up the page on Input.</p>

<p>This is the page on the input class.</p>

<p>We use this class to read the axis setup in the
input manager and to access multitouch
touch and accelerometer data
on mobile devices.</p>

<p>We read the text on the top of the page to
understand how to use the class.</p>

<p>In our case, to get input from the player
on all platforms, including mobile devices.</p>

<p>Under the description is a list of class
variables and class functions.</p>

<p>The class variables hold information
like the number of touches in touchCount
or a reference to the default gyroscope with gyro.</p>

<p>The class functions do something for us.</p>

<p>In our code we will be using Input.
GetAxis.</p>

<p>When we find the item we want we click on the link
to bring up a page on the function or the variable.</p>

<p>Let's look at Input.
GetAxis.</p>

<p>This page includes the signature of the function,
a description of the function
and code snippets showing how to use it
in Unity's Javascript and C#.</p>

<p>We will be using C#.</p>

<p>For more information on the input manager
and Input.
GetAxis see the lessons linked below.</p>

<p>We will be using Input.
GetAxis in a
very similar way to the code snippet.</p>

<p>Let's return to our script and write our code.</p>

<p>float moveHorizontal = Input.
GetAxis ("horizontal")
float moveVertical = Input.
GetAxis ("vertical")
This grabs the input from our player through the keyboard.</p>

<p>The float variables moveHorizontal and moveVertical
record the input from the horizontal
and vertical axis, which are controlled by the keys on a keyboard.</p>

<p>Our player game object uses a rigidbody
and interacts with a physics engine.</p>

<p>We will use this input to add forces to the rigidbody
and move the player game object in the scene.</p>

<p>To know more about how to apply forces to
the rigidbody let's check the documentation.</p>

<p>Type Rigidbody in to our script.</p>

<p>Now select rigidbody and hold down
the command key on the mac
or the control key on the pc
and type single quote.</p>

<p>Again, this brings a page with a search term "rigidbody".</p>

<p>We want to click on Rigidbody.</p>

<p>This brings up the rigidbody page.</p>

<p>If we want to apply force to our player game object
we need to do something.</p>

<p>So let's look at the functions available
to the rigidbody class.</p>

<p>We read the descriptions until we find
the one we want, in this case
let's choose AddForce.</p>

<p>This adds a force to the rigidbody
as a result the rigidbody will start moving.</p>

<p>Click the link and we go to the page on AddForce.</p>

<p>We can see the signature of the function
at the top of the page.</p>

<p>This signature tells us we need a vector3
and an optional ForceMode to add
force to our rigidbody.</p>

<p>What is a vector3?
For more detailed information on vector3
Please see the information linked below.</p>

<p>But in simple terms the vector3
holds 3 decimal values in one container.</p>

<p>This makes it easy for us to move around
and use values for things like a force in 3D space,
which requires a value for force on
each of the X, Y and Z axis.</p>

<p>Or to describe a rotation which would also require
a value for each of the X, Y and Z axis.</p>

<p>All of our documentation pages are linked together.</p>

<p>If we were to click on Vector3, we would be taken to the
documentation page for vector3.</p>

<p>The same is true for ForceMode, MonoBehaviour and RigidBody.</p>

<p>Below the description are snippets
that show us how this function could be used.</p>

<p>Note the second signature for AddForce below the first.</p>

<p>The descriptions are the same.</p>

<p>But in this case we can use AddForce with either a vector3
or 3 float values for X, Y and Z.</p>

<p>The next concept that we need to cover is
how to get a hold of, or how to reference
different components on our game object.</p>

<p>We are writing a script called PlayerController.</p>

<p>Which is attached as a script component
to our Player game object.</p>

<p>From this script we need to AddForce
using the rigidbody component.</p>

<p>We want to access that component from this script.</p>

<p>There are several ways that we can do this.</p>

<p>But in our case we will cover only one of the main ways
of accessing another component on the same game object.</p>

<p>We will create a variable to hold this reference in our script
and we will set this reference in the Start function.</p>

<p>We see this here in the code snippet.</p>

<p>public Rigidbody rb creates a public variable
with the type of rigidbody called rb
to hold the reference to the rigidbody we want to access.</p>

<p>In Start the reference is set by using the code
GetComponent
This will find and return a reference to the attached rigidbody,
if there is one.</p>

<p>All of the code in the start function is
called on the first frame that the script is active.</p>

<p>This is often the very first frame of the game.</p>

<p>Finally in FixedUpdate the attached rigidbody component
is accessed through the variable named rb
with rb.
AddForce.</p>

<p>So in our script we need to write
private Rigidbody rb to create the variable to hold the reference.</p>

<p>And in a new start function we need to write
rb=GetComponent
In FixedUpdate
let's use the simplest version of Rigidbody.
AddForce.</p>

<p>One that simply uses a vector3
and we will leave the ForceMode at default
by omitting it from our code.</p>

<p>So in our script we need to type
rb.
AddForce and then some vector3 value.</p>

<p>No how do we get our two float values
in to a vector3 value?
Let's create a new vector3 variable called Movement.</p>

<p>This will be equal to a new vector3
that is made up of an X, a Y and a Z.</p>

<p>The X, Y, Z values will determine the direction of the force
we will add to our ball.</p>

<p>What is our X value?
That would be moveHorizontal.</p>

<p>With this our left and right keys will add force
moving the ball to the left or right.</p>

<p>What is our Y? 0.</p>

<p>We don't want to move up at all.</p>

<p>What is our Z value? That would be moveVertical.</p>

<p>Now we use Movement, a vector3 value,
in rb.
AddForce
as rb.
AddForce(movement).</p>

<p>Let's save this script and return to Unity.</p>

<p>We check for errors in our footer or the console
and there are none.
 Good.</p>

<p>Let's test what we've written.</p>

<p>Hit Play, and by using the keys setup on the input manager
the ball moves in the scene.</p>

<p>But it's very slow.</p>

<p>This is too slow to be playable, but the basic concept
works 100%.</p>

<p>To stop testing leave play mode.</p>

<p>Let's return to our code and create a tool
that will give us control over the speed of the ball.</p>

<p>We need to multiply our movement by some value.</p>

<p>We could simply enter that value here on our script
but if we ever needed to make any tweaks or changes
we would have to return to our scripting editor
and change the value in the script and then recompile.</p>

<p>This takes time.</p>

<p>The solution is to create a public variable in our script.</p>

<p>Let's create a public float
called Speed.</p>

<p>By creating a public variable in our script
this variable will show up in the Inspector
as an editable property.</p>

<p>When we use a public variable we can make
all of our changes in the editor.</p>

<p>We then multiply Movement by Speed.</p>

<p>We now have control over our movement value
from inside the editor.</p>

<p>Let's save these changes and return to Unity.</p>

<p>When we return to the editor we can see our
PlayerController script now has a speed property.</p>

<p>Let's set this property to 1000.</p>

<p>Now enter play mode.</p>

<p>Whoa! Way too fast!
But changes are fast too.
 Exit play mode
and change the value to 500.</p>

<p>Hit Play.</p>

<p>That's a little better.</p>

<p>Congratulations, we can now move our character.</p>

<p>In the next assignment we'll talk about how to move the camera.</p>

<h1>
<a id="moving-the-camera" class="anchor" href="#moving-the-camera" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>MOVING THE CAMERA</strong>
</h1>

<p>The camera doesn't move and from it's current position
cannot see very much.</p>

<p>We need to tie the camera to the player game object.</p>

<p>First let's set the position of the camera.</p>

<p>Let's lift it up by 10 units and tilt it
down by about 45 degrees.</p>

<p>Next let's make the camera a child of the
player game object.</p>

<p>This is a typical third-person setup,
with the camera as a child of the player.</p>

<p>When we move the player's position
the camera moves with it.</p>

<p>When the player rotates the camera rotates as well.</p>

<p>Let's look at this from a position where we
can see both the player and the camera game object.</p>

<p>Move the player,
rotate the player,
the child camera moves with it.</p>

<p>Now let's reset the player and test.</p>

<p>We enter play move, hold down the up arrow to move,
Whoa what's happening here?
Okay, well as the camera is a child of the player's sphere,
even thought the camera is not moving at all
relative to the player's game object,
the player game object is rotating like crazy
so the camera's point of view rotates with it.</p>

<p>Let's exit play mode.</p>

<p>Unlike a normal third-person game
our player game object is rotating on all 3 axis
not just 1.</p>

<p>In a typical third-person setup
the camera as a child of the player game object
will always be in a position relative
to it's immediate parent,
and this position will be the parent's
position in the game, modified or offset by
any values in the child's transform.</p>

<p>We can't have the camera as a child of
the player, so let's detach it.</p>

<p>Our offset value will be the difference
between the player game object and the camera.</p>

<p>Now we need to associate the camera with
the player game object, not as a child
but with a script.</p>

<p>Using the Add Component button choose New Script.</p>

<p>We are writing in C#
and name the script CameraController
and then click on Create and Add
or simply hit the return or enter key
to confirm our selection.</p>

<p>We should note, this way of creating a script
will create that script asset on
the root or top level of our project view.</p>

<p>File CameraController in the Scripts folder
and open it for editing.</p>

<p>We need 2 variables here.</p>

<p>A public GameObject reference to the player
and a private vector3 to hold our offset value.</p>

<p>Offset is private because we can
set that value here in the script.</p>

<p>For our offset value we will take the
current transform position.</p>

<p>and subtract the transform position of the player
to find the difference between the two.</p>

<p>So in start we can make offset equal to our
transform position minus the player's transform position.</p>

<p>And then every frame we set our
transform position to our player's transform position
plus the offset.</p>

<p>This means as we move our player
with the controls on the keyboard
that each frame before displaying what the camera can see
the camera is moved in to a new position
aligned with the Player object.</p>

<p>Just as if it were a child of that object
if it were not rolling around the game board.</p>

<p>However, update is not the best place for this code.</p>

<p>It is true that update runs every frame
and in update each frame we can track
the position of the player's game object
and set the position of the camera.</p>

<p>However, for follow cameras, procedural animation,
and gathering last known states
it's best to use LateUpdate.</p>

<p>LateUpdate runs every frame, just like update.</p>

<p>But it is guaranteed to run after all items
have been processed in update.</p>

<p>So when we set the position of the camera
we know absolutely that the player has moved for that frame.</p>

<p>So let's test this.
 Let's save our script
and return to Unity.</p>

<p>First we need to create a reference to the
player game object by dragging the player
game object in to the Player slot
in the camera controller's component.</p>

<p>Enter play mode
and now we get the behaviour we want.</p>

<p>The camera follows the rolling ball
without rotating
even as the ball goes over the edge.</p>

<p>In the next assignment we will setup the basic
play area and create and place our
special pick-up objects.</p>

<h1>
<a id="setting-up-the-play-area" class="anchor" href="#setting-up-the-play-area" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>SETTING UP THE PLAY AREA</strong>
</h1>

<p>So let's set up our play field.</p>

<p>The play field for our game will be very simple.</p>

<p>We will place walls around the edges
to keep our player game object from falling off
and we will create and place a set of collectable
objects for our player to pick up.</p>

<p>First let's create a new game object
and rename it Walls.</p>

<p>This will be an organising parent game object
for our Wall objects.</p>

<p>Reset this game object to origin.</p>

<p>Now we will build our walls.</p>

<p>Let's start by creating a new cube
to be our first wall.</p>

<p>Rename this West Wall.</p>

<p>Reset this game object to origin.</p>

<p>Now parent West Wall to our Walls game object.</p>

<p>Let's focus our Scene view camera
to our Wall object.</p>

<p>We can do this by typing the F key
while the cursor is over the Scene view
or by selecting Edit - Frame Selected.</p>

<p>We need to change the size of the cube to fit
one side of our play area.</p>

<p>Change the cube's transform scale of X, Y and Z to
.
5 for thin, 2 for tall and 20.
5 for long.</p>

<p>Now we can simply push the wall in to place
using the Translate tool
or we could enter a value in to the transform component.</p>

<p>In this case we can set the transform's
position X value to -10.</p>

<p>This places the wall neatly to the edge of our play area.</p>

<p>To create the next wall we could
start with another new cube,
but then we'd have to rescale this
new cube before we placed it.</p>

<p>Our current West Wall is already the perfect size.</p>

<p>So let's duplicate the West Wall game object.</p>

<p>Let's rename it East Wall.</p>

<p>To place the wall simply remove the negative sign
and it pops in to place on the east side of our game area.</p>

<p>Now let's duplicate the east wall
and call it North Wall.</p>

<p>Reset the X position so the north wall
is in the centre of the play area.</p>

<p>We now have two choices.</p>

<p>We can rotate the wall by 90 degrees,
or, as this is a cuboid,
we can rescale the wall to 20.
5 in the X and 0.
5 in the Z.</p>

<p>Now it's scaled correctly for it's orientation
as the north wall.</p>

<p>We can drag the wall in to place,
or we can simply use the value of 10
in the transform's position Z field to place it.</p>

<p>Duplicate North Wall and call it South Wall,
and -10 in the Z axis pops it in to place.</p>

<p>Enter play mode and test.</p>

<p>Fantastic, the walls work fine.</p>

<p>Remember to test early and test often,
don't wait to test.</p>

<p>Let's exit play mode.</p>

<p>Let's highlight the Player game object
and set the editor to Local mode,
and try again.</p>

<p>Note how in Local mode we can see the transform rotate.</p>

<p>Let's exit play mode.</p>

<p>In the next episode we will be creating
our collectable pickup object.</p>

<h1>
<a id="creating-collectable-objects" class="anchor" href="#creating-collectable-objects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>CREATING COLLECTABLE OBJECTS</strong>
</h1>

<p>Next let's create our collectable objects.</p>

<p>Create a new cube
and rename it PickUp.</p>

<p>Reset the Pickup's transform to origin.</p>

<p>Focus the scene view camera on the Pickup object.</p>

<p>The Player game object is in the way.</p>

<p>Let's select the Player game object
and deselect the checkbox in front of the Name field.</p>

<p>This is the game object's Active checkbox.</p>

<p>Deselecting it will deactivate the game object in the scene.</p>

<p>This will give us a clear working space
for our new Pickup object.</p>

<p>The cube is buried in the plane, just like our player
sphere was when we started this project.</p>

<p>The cube is also a regular shape, 1 by 1 by 1.</p>

<p>So let's lift it up by half a unit
and we know it's resting on the plane.</p>

<p>This cube will be our Pickup object.</p>

<p>To be effective it must attract the attention of the Player.</p>

<p>So let's make the cube more attractive.</p>

<p>We will start by making it smaller.</p>

<p>This will also give it the effect of floating in above the play area.</p>

<p>Both will help identify this object as special.</p>

<p>Not enough however.</p>

<p>Let's tilt it over.</p>

<p>45, 45, 45 in each of the axis
of the transform's rotation.</p>

<p>Better, but not sexy enough.</p>

<p>One thing I feel certainly attracts the attention of a player,
and that is movement.</p>

<p>So let's rotate the cube.</p>

<p>To do this we need a script.</p>

<p>With the Pickup object selected
use the Add Component button in the Inspector.</p>

<p>Create a new script called Rotator.</p>

<p>Click Create and Add to confirm.</p>

<p>Organise the script by placing it in the Scripts folder,
and open it for editing.</p>

<p>We want the cube to spin,
and we want to do it with this script.</p>

<p>Let's remove the sample code we don't need.</p>

<p>We will not be using forces, so we can use
update rather than fixed update.</p>

<p>We have already set the transform rotation
in the transform component to 45, 45, 45
for the X, Y and Z axis.</p>

<p>But these values don't change by themselves.</p>

<p>We want to change these values every frame.</p>

<p>To make the cube spin we don't want to
set the transform rotation,
but we want to rotate the transform.</p>

<p>Next type Transform inside update.</p>

<p>Select it and hold down the control key on the PC
or the command key on the Mac
and type single quote.</p>

<p>Again, this brings up the page with a search term Transform.</p>

<p>Select Transform.</p>

<p>This brings up the Transform page in the documentation.</p>

<p>There are two main ways to effect the transform.</p>

<p>These are Translate and Rotate.</p>

<p>Translate moves the game object by it's transform.</p>

<p>Rotate rotates the game object by it's transform.</p>

<p>We will use Rotate.</p>

<p>So let's click on the link,
and this brings up the page for Transform Rotate.</p>

<p>Note again the two signatures
and the two possible overrides.</p>

<p>One using a vector3 and the other using
three float values for X, Y and Z.</p>

<p>Both overrides have the optional parameter Space.</p>

<p>Which we will leave at Default for this lesson.</p>

<p>Again we will choose the most simple
form that only uses the vector3 for direction.</p>

<p>Let's return to our code.</p>

<p>After transform, and make sure transform is written
to begin with a lowercase T,
write Rotate (new Vector3 (15, 30, 45)
Now this action also needs to be smooth
and frame rate independent.</p>

<p>So we need to multiply the vector3 value
by Time.
deltaTime.</p>

<p>Save this script and return to Unity.</p>

<p>Test by entering play mode, and our Pickup object rotates.</p>

<p>Let's exit play mode.</p>

<p>Okay, we have the start of a working Pickup object.</p>

<p>Next we want to place these around the game area.</p>

<p>But before we do this we need to do one important step.</p>

<p>We need to make our Pickup object in to a prefab.</p>

<p>So remember, a prefab is an asset that contains a template,
or blueprint of a game object or game object family.</p>

<p>We create a prefab from an existing game object
or game object family, and once created,
we can use this prefab in any scene in our current project.</p>

<p>With a prefab of our Pickup object
we will be able to make changes to a single
instance in our scene,
or to the prefab asset itself,
and all of the Pickup objects in our game
will be updated with those changes.</p>

<p>So first let's create a folder to hold our prefabs.</p>

<p>We want this folder on our root, or top level of our project.</p>

<p>So select the project view
and make sure that no other item or directory is highlighted.</p>

<p>And then choose Create - Folder
Rename this folder Prefabs.</p>

<p>Now drag the Pickup game object from our hierarchy
and place it in to our Prefabs folder.</p>

<p>When we drag an item from our hierarchy
in to our project view we create a new prefab asset
containing a template, or blueprint
of our game object or game object family.</p>

<p>Before we spread our collectables around the game area
we should create a new game object
to hold our Pickups and to help organise our hierarchy.</p>

<p>Let's create a new game object
and call it Pickups.</p>

<p>Check to make sure this parent game object is at origin
and drag our Pickup game object in to it.</p>

<p>Now we want to spread a number of these Pickup
objects around the play area.</p>

<p>First, make sure we have the Pickup game object
selected, not the parent.</p>

<p>Now let's move in to a top-down view
by clicking on the gizmo in to upper-right of our scene view.</p>

<p>Let's back out a little so we can see the entire game area.</p>

<p>Grab the Pickup game object,
and it doesn't move in the scene the way we want it to.</p>

<p>Note how the cube is moving in relation to
it's gizmo, which is tilted over.</p>

<p>What we are seeing is the game object moving in local mode.</p>

<p>We really want to move the Pickup game object
aligned with the ground.</p>

<p>Change the editor to Global mode.</p>

<p>Now see how the orientation of the gizmo changes?
And now we can drag our game object around
relative to the world's global axis.</p>

<p>So let's lay down a few of these in the game area.</p>

<p>Take our first Pickup object
and place it in to the game area, some place convenient.</p>

<p>I'm going to place mine at the top.</p>

<p>With the game object selected, duplicate it.</p>

<p>This can be done either by selecting Edit - Duplicate
or by using the hot key combination, this is command-D on the Mac
or control-D on the PC.</p>

<p>Now we place the second instance of the prefab.</p>

<p>Using the hot keys we will create a few more,
placing them around the play area.</p>

<p>Note that I'm moving parallel to the ground or the X/Z plane
by selecting the X/Z plane at the centre of the gizmo.</p>

<p>Okay, that's 12.</p>

<p>Let's hit play and test.</p>

<p>Excellent.</p>

<p>These Pickup prefabs are working great.</p>

<p>The only thing that I want them to do now
is stand out more against the background
walls and Player game object.</p>

<p>Let's change their colour/
To do this we need another material.</p>

<p>To make things easy we can simply
select our existing material and duplicate it.</p>

<p>Let's rename this new material Pickup.</p>

<p>With the material selected in the project view
let's change the albido colour property to yellow.</p>

<p>Now we can change the colour of the prefab
by changing the prefab's material.</p>

<p>We can do this in two ways.</p>

<p>We can change the material on just
one instantiated prefab
If we do this we must remember to
use the Apply button to apply
those changes to the prefab asset.</p>

<p>Otherwise we will only change the material
on this single instance.</p>

<p>The other way, which is perhaps more simple
is to simply change the material on the
prefab asset directly.</p>

<p>Let's hit play and test.</p>

<p>There, that looks better.</p>

<p>In the next assignment we will learn how to
pick them up and count them.</p>

<h1>
<a id="collecting-the-pick-up-objects" class="anchor" href="#collecting-the-pick-up-objects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>COLLECTING THE PICK UP OBJECTS</strong>
</h1>

<p>We want to be able to pick up our collectable game
objects when our player game object collides with them.</p>

<p>To do this we need to detect our collisions
between the player game object and
the PickUp game objects.</p>

<p>We will need to have these collisions
trigger a new behaviour and we will need to
test these collisions to make sure we are
picking up the correct objects.</p>

<p>The PickUp objects, the player's sphere,
the ground plane and the walls all have
colliders that inform us about collisions.</p>

<p>If we didn't test our collisions to find out
which objects we have collided with
we could collect the wrong objects.</p>

<p>We could collect the floor, or the walls.</p>

<p>As a matter of face if we didn't test our collisions
on the very first frame of the game we would
come in contact with the ground plane
and we would collect the ground plane
and then we would fall in to the void of the scene space
and the game would essentially be over.</p>

<p>First, we don't need our player to remain inactive.</p>

<p>so let's tick the Active checkbox and
bring back our player.</p>

<p>Next let's select the PlayerController script
and open it for editing.</p>

<p>Just a note, we could edit this
script regardless of whether the game
object is active or not.</p>

<p>Now that we have the script open,
what code are we going to write?
We could write collider
and then search the documentation using the
hot key combination.</p>

<p>But there is a different way that we could do this as well.</p>

<p>Let's return to Unity and look at the details
of our player game object.</p>

<p>What we are interested in here is the
sphere collider component.</p>

<p>In the header of each component on the left
is the component's turndown arrow,
the icon, the Enable checkbox
if it's available, and the type of the component.</p>

<p>On the right is the context sensitive gear gizmo
and an icon of a little book with a question mark.</p>

<p>Now this is what we need.</p>

<p>This is the quick link to the component reference.</p>

<p>If we select this icon we are taken
not to the scripting reference but to the
component reference.</p>

<p>We would read this document to find out more
about how to use this component in the context
of the editor.</p>

<p>We, however, want to find out how to
script to this component's class.</p>

<p>To do this we simply switch to scripting
and we are taken to the scripting reference
for the sphere collider.</p>

<p>We want to detect and test our collisions.</p>

<p>For this project we are going to use
OnTriggerEnter.</p>

<p>Just imagine if we were, say, a daring plumber
and we jumped up to collect a perfect arch of coins
and bounced off the very first one as we
collected it and fell back to the ground.</p>

<p>Not very elegant.</p>

<p>This code will give us the ability to detect
the contact between our player game object
and our PickUp game objects
without actually creating a physical collision.</p>

<p>The code example however is not exactly
what we're looking for.</p>

<p>But that's okay, we can change that.</p>

<p>First, let's copy the code,
and then let's return to our scripting application.</p>

<p>Now that we're back in scripting let's paste the code.</p>

<p>As we have copied this code from a webpage
let's correct the indents.</p>

<p>In this case I'm going to make sure the
indents are tabs and that all of the tabs are
correctly aligned.</p>

<p>Next, let's look at this code.</p>

<p>We are using the function OnTriggerEnter.</p>

<p>OnTriggerEnter will be called by Unity
when our player game object first touches
a trigger collider.</p>

<p>We are given as an argument
a reference to the trigger collider that we have touched.</p>

<p>This is the collider called Other.</p>

<p>This reference gives us a way to get a
hold of the colliders that we touch.</p>

<p>With this code, when we touch another trigger
collider we will destroy the game object
that the trigger collider is attached to
through the reference other.
gameObject.</p>

<p>By destroying that game object, the game object,
all of it's components and all of it's
children and their components are removed
from the scene.</p>

<p>For the sake of example in this assignment
we won't destroy the other game object
we will deactivate it.</p>

<p>Just like we deactivated the player object
when we were creating our PickUp objects.</p>

<p>First, let's remove the Destroy(other.
gameobject)
code from the function.</p>

<p>But let's paste it down below our script
as a palette to work with.</p>

<p>How will we deactivate our PickUp objects?
Well what clues do we have?
We can address the other collider's game
object through other.
gameObject.</p>

<p>We can see this here in the sample code.</p>

<p>And we want to test the other game object
and if it's a PickUp object we want to deactivate
that game object.</p>

<p>So let's look up GameObject
with our hot key combination and see what we can find.</p>

<p>Now we have the page on GameObject.</p>

<p>There are two important items here that we want.</p>

<p>They are tag,
tag allows us to identify the game object
by comparing the tag value to a string.</p>

<p>And SetActive.</p>

<p>This is how we activate or deactivate a game object through code.</p>

<p>The last item we need to know about is
Compare Tag.</p>

<p>Compare Tag allows us to efficiently
compare the tag of any game object to a sting value.</p>

<p>Let's open up these three items, each in their own tab.</p>

<p>Tag allows us to identify a game object by a tag value.</p>

<p>We must declare our tags in the Tags and Layers Panel before using them.</p>

<p>It is possible to test a tag against a string value directly
with code like
if gameObject.
tag is the same as some string value.</p>

<p>But there is a more efficient built-in way to do this,
and that is CompareTag
With CompareTag we can efficiently
compare the tag of any game object with a string value.</p>

<p>Let's copy the sample code and
paste it in to our working palette.</p>

<p>Now GameObject.
SetActive.</p>

<p>This is how we activate or deactivate a game object.</p>

<p>This is the code equivalent of clicking
the Active check box next to the
Name field in the Inspector.</p>

<p>In our case, just like the code snippet,
we will call GameObject.
SetActive (false)
to deactivate our PickUp game objects.</p>

<p>Let's copy this code and returning to our script editor
paste it in to our palette as well.</p>

<p>I feel we have enough pieces to write our code
so let's write if (other.
gameObject.
CompareTag
with the string value of PickUp
and we will have to define this tag in Unity later.</p>

<p>other.
gameObject.
SetActive (false);
Now this code will be called every time
we touch a trigger collider.</p>

<p>We are given a reference to the collider we touch,
we test it's tag,
and if the tag is the same as the string value
PickUp we will take the other game object
and we will call SetActive (false),
which will deactivate that game object.</p>

<p>Now we don't need this code we've been saving anymore
and keeping it will only confuse the compiler
so we can delete it.</p>

<p>Let's save this script and return to Unity
and check for errors.</p>

<p>The first thing we need to do it set up the tag value
for the PickUp objects.</p>

<p>Select the prefab asset for the PickUp object.</p>

<p>When we look at the tag list
we don't see any tag called PickUp
so we need to add one.</p>

<p>Select Add Tag.</p>

<p>This brings up the Tags and Layers Panel.</p>

<p>Here we can customise tags and layers.</p>

<p>Note that this list is empty.</p>

<p>To create a new custom tag select the + button
to add a new row to the tags list.</p>

<p>In the new empty element, in our case tag 0,
type PickUp, and this is case sensitive
and needs to be exactly the same string
that we have in our script.</p>

<p>If in doubt we can copy and paste
this string to get the exact value.</p>

<p>When we look back at the prefab asset
note that the asset is still untagged.</p>

<p>By selecting Add Tag we changed our focus
from the prefab asset to the Tag Manager
and in the Tag Manager we created our tag.</p>

<p>Now we need to apply that tag
to the prefab asset.</p>

<p>Select the Tag drop down again
and see how we now have PickUp in the list.</p>

<p>Select this tag from the list and the asset
is now tagged PickUp.</p>

<p>And with the power of prefabs
all of the instances are now tagged PickUp as well.</p>

<p>Now let's test our game.</p>

<p>Save the scene and enter play mode.</p>

<p>Hmm, okay, our tag is set to PickUp
but we are still bouncing off the PickUp cubes
just like we are bouncing off the walls.</p>

<p>So let's exit play mode.</p>

<p>Before we discuss why we are bouncing off
the PickUp cubes rather than picking them up
we need to have a brief discussion about
Unity's physics system.</p>

<p>I'm going to enter play mode for this discussion.</p>

<p>Let's look at one of our cubes and our player.</p>

<p>As an aside we can select two or
more game objects at the same time
and inspect them all.</p>

<p>We do this by holding down the command key
on the mac or the control key on the PC,
and selecting the game objects.</p>

<p>When we select multiple game objects
note how the inspector changes to show
the common components and property
values of the selected game objects.</p>

<p>The inspector also allows for multi-object editing.</p>

<p>Using multi-object editing I'm going to
disable the mesh renderer on both the
player's sphere and the selected cube with a single click.</p>

<p>This leaves us with the two green outlines
of the collider volumes for these two objects.</p>

<p>How do collisions work in Unity's physics engine?
The physics engine does not allow two collider
volumes to overlap.</p>

<p>When the physics engine detects that any two
or more colliders will overlap that frame
the physics engine will look at the objects and
analyse their speed and rotation and shape
and calculate a collision.</p>

<p>One of the major factors in this calculation
is whether the colliders are static
or dynamic.</p>

<p>Static colliders are usually non-moving
parts of your scene, like the walls, the floor,
or the fountain in the courtyard.</p>

<p>Dynamic colliders are things that move
like the player's sphere or a car.</p>

<p>When calculating a collision the static geometry
will not be affected by the collision.</p>

<p>But the dynamic objects will be.</p>

<p>In our case the player's sphere is dynamic,
or moving geometry, and it is bouncing
off the static geometry of the cubes.</p>

<p>Just as it bounces off the static geometry
of the walls.</p>

<p>The physics engine can however allow the
penetration or overlap of collider volumes.</p>

<p>When it does this the physics engine
still calculates the collider volumes and
keeps track of the collider overlap.</p>

<p>But it doesn't physically act on the overlapping
objects, it doesn't cause a collision.</p>

<p>We do this by making our colliders in to
triggers, or trigger colliders.</p>

<p>When we make our colliders in to a trigger,
or trigger collider, we can detect
the contact with that trigger through the
OnTrigger event messages.</p>

<p>When a collider is a trigger you can do
clever things like place a trigger in the middle
of a doorway in, say, an adventure game,
and when the player enters the trigger
the mini-map updates and a message plays
'you have discovered this room'.</p>

<p>Or every time your player walks around
that corner spiders drop from the ceiling
because the player has walked through a trigger.</p>

<p>For more information on OnCollision and on
trigger messages see the lessons linked below.</p>

<p>We are using OnTriggerEnter in our code
rather than OnCollisionEnter.</p>

<p>So we need to change our collider volumes
in to trigger volumes.</p>

<p>To do this we must be out of play mode.</p>

<p>Let's select the prefab asset and look at
the box collider component.</p>

<p>Here we select Is Trigger
and again the power of prefabs
all of our PickUp objects are now using trigger colliders.</p>

<p>Let's save our scene, enter play mode and test.</p>

<p>And as our player enters the trigger
we pickup the objects.</p>

<p>Excellent.</p>

<p>Let's exit play mode.</p>

<p>Everything looks great.</p>

<p>We only have one issue.</p>

<p>We have made one small mistake,
and this is related to how Unity
optimises it's physics.</p>

<p>As a performance optimisation Unity
calculates all the volumes
of all the static colliders in a scene
and holds this information in a cache.</p>

<p>This makes sense as static colliders
shouldn't move, and this saves recalculating this
information every frame.</p>

<p>Where we have made our mistake is by rotating our cubes.</p>

<p>Any time we move, rotate, or scale a static collider
Unity will recalculate all the static colliders again
and update the static collider cache.</p>

<p>To recalculate the cache takes resources.</p>

<p>We can move, rotate or scale dynamic
colliders as often as we want and Unity won't
recache any collider volumes.</p>

<p>Unity expects us to move colliders.</p>

<p>We simply need to indicate to Unity which
colliders are dynamic before we move them.</p>

<p>We do this by using the rigid body component.</p>

<p>Any game object with a collider
and a rigid body is considered dynamic.</p>

<p>Any game object with a collider attached
but no physics rigid body is expected to be static.</p>

<p>Currently our PickUp game objects have a
box collider but no rigid body.</p>

<p>So Unity is recalculating our static
collider cache every frame.</p>

<p>The solution is to add a rigid body
to the PickUp objects.</p>

<p>This will move the cubes from being static colliders
to being dynamic colliders.</p>

<p>Let's save and play.</p>

<p>And our cubes fall through the floor.</p>

<p>Gravity pulls them down, and as they are triggers
they don't collide with the floor.</p>

<p>Let's exit play mode.</p>

<p>If we look at the rigid body component
we could simply disable Use Gravity,
which would prevent the cubes from being pulled downwards.</p>

<p>This is only a partial solution however.</p>

<p>If we did this, even though our cubes
would not respond to gravity they would still
respond to physics forces
There is a better solution.</p>

<p>And that is to select Is Kinematic.</p>

<p>When we do this we set this rigid body component to be
a kinematic rigid body.</p>

<p>A kinematic rigid body will not react
to physics forces and it can be animated
and moved by it's transform.</p>

<p>This is great for everything from objects with colliders
like elevators and moving platforms,
to objects with triggers, like our collectables
that need to be animated or moved by their transform.</p>

<p>For more information on the rigid body
and Is Kinematic see the lessons linked below.</p>

<p>Let's save our scene and enter play mode to test.</p>

<p>Now our behaviour is identical and performant.</p>

<p>So, static colliders shouldn't move,
like walls and floors.</p>

<p>Dynamic colliders can move,
and have a rigid body attached.</p>

<p>Standard rigid bodies are moved using physics forces.</p>

<p>Kinematic rigid bodies are moved using
their transform.</p>

<p>In the next assignment we will count our
collectable object and make a simple UI
to display our score and messages.</p>

<h1>
<a id="displaying-the-score-and-text" class="anchor" href="#displaying-the-score-and-text" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>DISPLAYING THE SCORE AND TEXT</strong>
</h1>

<p>Counting, displaying text and ending the game.</p>

<p>We need a tool to store the value
of our counted collectables.</p>

<p>And another tool to add to that value
as we collect and count them.</p>

<p>Let's add this tool to our PlayerController script.</p>

<p>Select the Player game object and open the
PlayerController script for editing.</p>

<p>Let's add a private variable to hold our count.</p>

<p>This will be an int, as our count will be
a whole number, we won't be collecting partial objects,
and let's call it Count.</p>

<p>So in our game we will first start
with a count of 0.</p>

<p>Then we will need to increment our count value
by 1 when we pick up a new object.</p>

<p>First we need to set our count value to 0.</p>

<p>As this variable is private we don't have
any access to it in the Inspector.</p>

<p>This variable is only available for use within this script
and as such we will need to set it's starting value
here in the script.</p>

<p>There are several ways we can set the starting value
of Count, but in this assignment we will
do it in the Start function.</p>

<p>In Start set our Count to be equal to 0.</p>

<p>Next we need to add to Count when we pick up
our collectable game objects.</p>

<p>We will pick up our objects in OnTriggerEnter
if the Other game object has the tag Pickup.</p>

<p>So this is where we add our counting code.</p>

<p>After setting the other game objects
active state to False we add our new value of Count
is equal to our old value of Count plus 1.</p>

<p>There are other ways to add, count up or increment
the value when coding for Unity,
but this one is very easy to understand and
this is the one that we're going to use in this assignment.</p>

<p>Save this script and return to Unity.</p>

<p>Now we can store and increment our count
but we have no way of displaying it.</p>

<p>It would also be good to display a message
when the game is over.</p>

<p>To display text in this assignment we will
be using Unity's UI Toolset
to display our text and values.</p>

<p>First let's create a new UI text element
from the hierarchy's Create menu.</p>

<p>Let's look at what we've added to the hierarchy.</p>

<p>We seem to have gotten more than we bargained for.</p>

<p>We don't just have a UI text element,
but we've also created a parent
canvas element and an event systems game object.</p>

<p>These are all required by the UI toolset.</p>

<p>The single most important thing to know about
these additional items is that all UI elements must
be the child of a canvas to behave correctly.</p>

<p>For more information on the UI tools,
including the canvas and the events system
please see the information linked below.</p>

<p>Rename the text element CountText.</p>

<p>So let's customise this element a bit.</p>

<p>The default text is a bit dark.</p>

<p>Let's make the text colour white,
so it's easier to see.</p>

<p>The size and alignment are good.</p>

<p>And let's add some placeholder text
Count Text.</p>

<p>We want our text to display in the upper left
of the screen when the game is playing.</p>

<p>We can see that the UI text is currently
displaying in the centre of the screen in the game view.</p>

<p>This is because the text element is anchored
to the centre of it's parent,
which is, in this case, the canvas.</p>

<p>It is worth noting that the transform component on UI elements
is different from the other game objects in Unity.</p>

<p>For UI elements the standard transform has been replaced
with the rect transform,
which takes in to account many specialised features
necessary for a versatile UI system,
including anchoring and positioning.</p>

<p>For more information on the rect transform
please see the information linked below.</p>

<p>One of the easiest ways to move the
count text element in to the upper left
is to anchor it to the upper left corner of
the canvas, rather than to it's centre.</p>

<p>To do this open the Anchors and Presets menu
by clicking on the button displaying the current anchor preset.</p>

<p>When we re-anchor this text element
we also want to set the pivot
and the position based on the new anchor.</p>

<p>So we will hold down both the Shift and the Alt keys
and the select the upper left corner button.</p>

<p>That's done it, it's up in the corner.</p>

<p>But now it looks budged up against the
corner of the game view.</p>

<p>Let's give it some space between the text
and the edges of the screen.</p>

<p>As we are anchored to the upper left corner of the canvas
and we have set our pivot to the upper left corner as well
the easiest way to give the text a little breathing room
is to change the rect transform's
Pos X and Pos Y values.</p>

<p>10 and -10 seems about right,
with some room around it, yet it's still up and out of the way.</p>

<p>So let's wire up the UI text element
to display our count value.</p>

<p>Start by opening the PlayerController script for editing.</p>

<p>Before we can code anything related to any UI elements
we need to tell our script more about them.</p>

<p>The details about the UI toolset
are held in what's called a namespace.</p>

<p>We need to use this namespace
just as we are using UnityEngine and System.
Collections.</p>

<p>So to do this, at the top of our script write
using UnityEngine.
UI.</p>

<p>With this in place we can now write our code.</p>

<p>First create a new public text variable
called countText
to hold a reference to the UI text
component on our UI
text game object.</p>

<p>We need to set the starting value of the
UI text's Text property.</p>

<p>We can do this in Start as well.</p>

<p>Write countText.
Text = "Count: "</p>

<ul>
<li>count.
ToString, and we need the parenthesis.</li>
</ul>

<p>Now this line of code must be written
after the line setting our count value.</p>

<p>Count must have some value for us to set a text with.</p>

<p>Now we also need to update this text property
every time we pick up a new collectable
so in OnTriggerEnter after we increment our count
value let's write again
countText.
Text = 'Count: ' + count.
ToString();
Hmm, we've now written the same line of code
twice in the same script.</p>

<p>This is generally bad form.</p>

<p>One way to make this a little more elegant
is to create a function that does the work in one place
and we simply call this function every time we need it.</p>

<p>Let's create a new function with void SetCountText
and then an empty set of parenthesis and brackets.</p>

<p>Now let's move one instance of this line of code
in to the function by cutting and pasting it.</p>

<p>And in it's place let's put a line of code
simply calling the function.</p>

<p>Finally let's replace the other line with
the function call as well.</p>

<p>Excellent.
 Save and swap back to Unity.</p>

<p>Now we see our PlayerController script has
a new text property.</p>

<p>We can associate a reference to our Count text
simply by dragging and dropping the
CountText game object on to the slot.</p>

<p>Unity will find the text component
on the game object and correctly associate the reference.</p>

<p>Now let's save, enter play mode and test.</p>

<p>Ah-ha! Not only do we collect
these objects but we count them now.</p>

<p>Let's exit play mode.</p>

<p>We need to display a message when we have
collected all of the cubes.</p>

<p>To do this we will need another UI text object.</p>

<p>Again, using the hierarchy's Create menu
make a new UI text game object.</p>

<p>Rename it Win Text.</p>

<p>Note how the new UI text element
is automatically added to our canvas.</p>

<p>Again, as before, let's customise the values on the component.</p>

<p>Let's colour the text white so it is easier to see.</p>

<p>Let's make the text a little larger,
let's try about 24.</p>

<p>Lastly, let's adjust the alignment to centre and middle.</p>

<p>And again let's add placeholder text
Win Text.</p>

<p>We want this text to display in the centre of the game screen
but up a little so it doesn't cover the player game object.</p>

<p>To do this simply adjust the rect transform's
Pos Y value as by default this UI text element
is anchored to the centre of the canvas.</p>

<p>A value of about 75 feels good.</p>

<p>Save the scene and swap back to our scripting editor.</p>

<p>We need to add a reference for this UI text element.</p>

<p>Create a new public text variable
and call it winText.</p>

<p>Now let's set the starting value for the
UI text's text property.</p>

<p>This is set to an empty string or two
double quote marks with no content.</p>

<p>This text property will start empty.</p>

<p>Then in the SetCountText function let's write
if Count is greater than or equal to 12,
which is the total number of objects we have in the
game to collect, then our winText.
Text equals You Win.</p>

<p>Save this script and return to Unity.</p>

<p>Again on our player,
our PlayerController has a new UI text property.</p>

<p>We can associate the component
again by dragging the WinText game object in to the slot.</p>

<p>Save the scene and play.</p>

<p>So we're picking up our game objects,
we're counting our collectables,
and
we win!
And as we can see when we have collected 12 objects
we display the 'You Win' text.</p>

<p>In the next and last assignment of this series
we will build the game and deploy it using a standalone player.</p>

<h1>
<a id="building-the-game" class="anchor" href="#building-the-game" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>BUILDING THE GAME</strong>
</h1>

<p>Now that we've finished our game we need to
present it to our players.</p>

<p>One of the greatest things about Unity is that
once we have created our game we can deploy
it to many of the current platforms.</p>

<p>For more detailed information on building and
build targets please see the lesson linked below.</p>

<p>Before we build our game we should
save our scene.</p>

<p>To build our game we must first open
the Build Settings window.</p>

<p>We can do this by selecting File - Build Settings
or by using the key combination of
shift plus command or control plus B.</p>

<p>This brings up the Build Settings window.</p>

<p>Our current build target is indicated by the Unity logo.</p>

<p>The blue highlight indicates our focus and
shows us on the right hand side the build
options for the currently selected platform.</p>

<p>We want to build a standalone application.</p>

<p>This is our current build target.</p>

<p>PC, Mac and Linux Standalone.</p>

<p>We do not need to change our build target.</p>

<p>If we did want to change our build target
we can select the desired platform from the list
and click the Switch Platforms button at the bottom of the window.</p>

<p>Let's now return our build target to the standalone player.</p>

<p>Once we have selected our new build target
we need to add the scenes we want to build
to the Build Settings window.</p>

<p>We can add the current scene by clicking the
Add Current button.</p>

<p>Or we can drag and drop any scene from our
project view in to the field at the top of
the Build Settings window.</p>

<p>It's worth noting that we don't need to
include every scene in our project.</p>

<p>We only need to include the scenes we
we want in our game.</p>

<p>It is also possible to perform a build
with no scenes in the build Settings window.</p>

<p>If we do this, Unity will simply build our game
using the current scene we have open for editing.</p>

<p>Now we are ready to build our game.</p>

<p>Let's return to the Build Settings window
and click the Build button.</p>

<p>This will bring up a dialogue box asking us
to choose a build location.</p>

<p>I like to associate my build location with
my project, so I will create a new folder
inside my project called Builds.</p>

<p>This folder must be placed only on the
root of our project alongside the
assets and library folders.</p>

<p>With the build folder selected let's name the build
and then click save.</p>

<p>Unity will now build the application
and save it to our Builds folder
When building for the Mac Unity builds a .
app bundle,
which contains all of the relevant data and files.</p>

<p>When building for Windows
Unity builds a .
exe file
and a data folder which contains all of the necessary resources.</p>

<p>To run the game, simply run the executable application.</p>

<p>And now we are running our game.</p>

<p>And, we win!
So in these assignments we have learned how to
create new game objects, how to position them in the scene,
add new components to them, write our own custom behaviours
for them using simple scripting.</p>

<p>We've seen how to use lights, cameras,
colliders, triggers, rigid bodies.</p>

<p>We can collect and count objects.</p>

<p>Though this is a very simple example,
it covers a large set of basic
subjects important to understanding how to use Unity.</p>

<p>For continued learning about Unity check the Learn site
for more lessons, assignments and projects.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/Ippokratis/Roll-a-ball">Roll-a-ball</a> is maintained by <a href="https://github.com/Ippokratis">Ippokratis</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
