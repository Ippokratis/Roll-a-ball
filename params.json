{
  "name": "Roll-a-ball",
  "tagline": "roll-a-ball unity3d written tutorial",
  "body": "# **INTRODUCTION TO ROLL-A-BALL**\r\n\r\nIn this beginner assignment we are going\r\nto make a very simple but playable game to\r\nuse many of the basic concepts from the\r\nbeginner tutorial modules.\r\n\r\nWe will be making a roll-a-ball game where\r\nwe will collect special game objects.\r\n\r\nWe will see how to create new game objects,\r\nadd components to these game objects,\r\nset the values on their properties and position\r\nthese game objects in the scene to create a game.\r\n\r\nIn our game the player will control a ball\r\nrolling around the game board.\r\nWe will move the ball using physics and forces.\r\nWe will look at the input from the player\r\nthrough the keyboard and we'll use those\r\ninputs to apply forces to the ball, making it\r\nmove in our scene.\r\n\r\nWe will see how to detect contact between\r\nthe player's ball and the pick-up game objects,\r\nand use these events to collect these\r\npick-up game objects.\r\n\r\nWhen we are done we will have made a simple\r\nroll-a-ball game where the player controls\r\nthe ball with the keyboard, picks up and\r\ncounts special collectable objects,\r\ndisplays the current count and ends the game\r\nwhen all of the game objects\r\nhave been picked up.\r\n\r\nWe won't need to import any assets for this project.\r\n\r\nWe won't be using models, textures,\r\nsounds or animations for this assignment.\r\n\r\nWe will simply use the primitive shapes\r\nlike cubes, spheres and planes\r\nprovided by Unity.\r\n\r\nTo begin, start with assignment 1 where we\r\nsetup our game and starting game objects.\r\n\r\n# **SETTING UP THE GAME** #\r\n\r\nLet's begin by creating a new project.\r\n\r\nWe can create a new project from File - New Project.\r\nThis will bring up the home screen.\r\n\r\nI'm going to call the new project Roll a Ball.\r\n\r\nThe next thing we need to do is set the destination,\r\nor path to our new project.\r\n\r\nI'm going to put this new project on my desktop.\r\nAt this point it's worth noting that we can\r\nhave our new project use default settings\r\nfor either a 2D project or a 3D project.\r\n\r\nWe will choose 3D.\r\n\r\nAnd then I will click on Create Project\r\nto make a new project.\r\n\r\nWe now have our new project with a new empty scene.\r\n\r\nBefore creating anything in the new scene\r\nwe need to save our scene.\r\n\r\nWe can save our scene by going to File - Save Scene\r\nor by using the keyboard shortcut.\r\n\r\nI'm going to save this scene in the Assets directory\r\nin a new folder called _scenes.\r\n\r\nThe underscore is optional, I use it to sort this\r\nfolder to the top of my project window.\r\n\r\nNow I'm going to call the scene MiniGame.\r\nWe can now see in our Scenes folder\r\nthe scene called MiniGame.\r\n\r\nLet's create our game board, or play field.\r\n\r\nTo do this we will use a stock Unity plane.\r\n\r\nWe can create this plane from either\r\nGame Object - 3D Object - Plane.\r\n\r\nOr from inside the Hierarchy view using the Create menu.\r\n\r\nRename this game object Ground.\r\nWe can do this by either selecting the game object\r\nand using the enter or return keys\r\nto allow editing, or by clicking on the\r\ngame object twice, slowly.\r\n\r\nType in the new name or hit enter or return\r\nto confirm this change.\r\n\r\nReset the transform component using the context\r\nsensitive gear menu in the upper right.\r\n\r\nThis will place the game object at the location of\r\n(0, 0, 0) in our scene.\r\n\r\nThis point is known as the origin point\r\nof the world and this is where all of the\r\ncoordinates in the scene are calculated from.\r\n\r\nNow with the game object selected and the\r\ncursor over the Scene view type the F key, or choose\r\nFrame Selected from the Edit menu\r\nto see the entire game object in the Scene view.\r\n\r\nLooking at our current scene,\r\nwe can see grid lines indicating the plane at origin.\r\n\r\nFor the purposes of this project\r\nwe will turn them off.\r\n\r\nSelect the Gizmos menu in the Scene view\r\nand deselect Show Grid.\r\n\r\nWe need to change the scale of the ground plane.\r\n\r\nWe can do this in a number of ways..\r\n\r\nWe can use the Scale tool,\r\nsimply grab the axis handle you want to change\r\nand drag the handle rescaling the plane.\r\n\r\nWe can click and drag on the title of\r\nthe fields we want to change.\r\n\r\nOr we can type a number directly in to the\r\nfield we want to change.\r\n\r\nYou can tab between fields and hit enter or return\r\nto confirm your choice.\r\n\r\nNow remember a plane has no volume\r\nand scale does not work on the Y axis.\r\n\r\nThere will be no change unless you go in to negative numbers.\r\n\r\nIn this case the plane, which is a single\r\nsided object will simply face the other direction.\r\n\r\nIf you place a plane in the scene and you can't see it\r\ncheck your orientation between the plane and camera\r\nand make sure that you have the correct values\r\nfor the Y axis of scale.\r\n\r\nThis is usually the value of 1.\r\n\r\nLet's create our player object.\r\n\r\nIn this assignment our player object\r\nwill be a Unity sphere.\r\n\r\nFrom the Hierarchy - Create menu select Sphere.\r\n\r\nRename the sphere Player.\r\n\r\nReset the transform to make sure it's a origin.\r\n\r\nSelect Edit - Frame Selected\r\nor use the F key while the cursor is\r\nover the Scene view to focus our Scene view\r\ncamera on our game object.\r\n\r\nSee how the sphere is buried in the plane?\r\n\r\nThis is because both game objects\r\nare in the exact same location in the scene,\r\nthe origin point, or (0, 0, 0)\r\n\r\non the X, Y and Z axis.\r\nWe need to move the player's sphere up\r\nuntil it rests on the plane.\r\n\r\nAll Unity primitive objects, cubes, spheres, capsules,\r\nhave a standard size, they are either\r\n1 by 1 by 1 or 1 by 2 by 1 Unity units.\r\n\r\nAs such we simply lift the player object up\r\nby half a unit in the Y axis\r\nand we know it is laying perfectly on top of plane.\r\nIf we look in the Game view we can that the\r\nplayer game object is lit and it\r\ncasts a shadow on the plane.\r\n\r\nAll new Unity scenes come with the\r\ndefault sky box and a directional light\r\nto represent the sun, so we don't need to worry\r\nabout setting up any default lighting.\r\n\r\nWhat could be improved however is the\r\nwhite player sphere on the white background.\r\nLet's add some colour to our background\r\nso there is some contrast between the player and the play field.\r\n\r\nTo add colour or texture to a model\r\nwe need to use a material.\r\n\r\nWe won't go in to the details of materials now,\r\nand we won't be using any textures.\r\n\r\nWe will simply use a standard material\r\nto add colour to the objects in our scene.\r\n\r\nFirst let's create a new folder in our\r\nproject to hold our materials.\r\n\r\nWe can do this by using the project's\r\nCreate menu and selecting Folder.\r\n\r\nRename this folder Material.\r\n\r\nWith the Materials folder selected\r\nuse the project's Create menu again\r\nand this time select Material.\r\n\r\nNote how the material was created in the Materials folder.\r\n\r\nThis is because we had the folder selected\r\nwhen we chose to create our new material\r\n\r\nRename this material Background.\r\n\r\nSelect the material and under Main Maps\r\nthe first property is Albido.\r\n\r\nClick on the Albido's colour field\r\nto open a colour picker.\r\n\r\nChange the colour to a nice dark shade of blue.\r\n\r\nIn our case I will use the RGB values of 0, 32, 64.\r\n\r\nFor a preview of the material make sure\r\nthat the preview window is open.\r\n\r\nTo apply the texture to the plane,\r\nsimply select the material in the project view\r\nand drag it on to the plane in the scene view.\r\n\r\nNow the player stands out on the dark blue background.\r\n\r\nI want to make one additional change that\r\nwill help us later in this project.\r\n\r\nI want to rotate the main directional light\r\nso that we have better lighting on our player.\r\n\r\nSelect the directional light and in the transform component\r\nchange the Transform Rotation on the Y axis to 60.\r\n\r\nThis will give better shape to our player sphere.\r\n\r\nNow we have a player game object and a background play field.\r\n\r\n# **MOVING THE PLAYER** #\r\n\r\nNow we are going to move the player game object.\r\n\r\nFirst let's think through how we want this player\r\ngame object to behave.\r\n\r\nWe want to have the sphere roll around on the\r\ngame area, bump in to walls, stay on the ground\r\nand not fly off in to space.\r\n\r\nWe want to be able to collide with our collectible\r\ngame objects and pick them up when we do.\r\n\r\nThis requires physics.\r\n\r\nTo use physics the game object needs\r\na rigidbody component attached.\r\n\r\nTo attach a new component we must first\r\nselect the game object we want to attach\r\nthe component to, in this case we will select\r\nour player game object.\r\n\r\nThen we can either choose the Component menu\r\nand select Physics - Rigid Body\r\nwhich would attach this component to the game object\r\nwe have selected.\r\n\r\nOr use the Add Component button in the Inspector\r\nchoosing Physics - Rigid Body.\r\n\r\nEither way this attached the rigidbody\r\ncomponent to the selected game object.\r\n\r\nIf we choose to we can rearrange the\r\norder of the components on the game object\r\nusing the context sensitive gear menu\r\nin the upper right of the component.\r\n\r\nDoing this has no effect on the performance of our game.\r\n\r\nHowever, having a consistent order to the components\r\non our game object may help us speed up our development\r\nby keeping or maintaining an organised\r\nproject and hierarchy.\r\n\r\nDon't forget, you can collapse or expand\r\nthe Component view by clicking on the component's title bar.\r\n\r\nWe should note that whenever we do this\r\nthis will also toggle the relevant\r\ngizmos for that component in the Scene view.\r\n\r\nNow we need to get the player object moving\r\nunder our control.\r\n\r\nTo do this we need to get input from our player\r\nthrough the keyboard and we need to apply\r\nthat input to the player game object as forces\r\nto move the sphere in the scene.\r\n\r\nWe will do this by using a script that\r\nwe attach to the player game object.\r\n\r\nFirst let's create a folder in our project view\r\nto hold our script assets.\r\n\r\nIn the Project view click on the Create menu\r\nand choose Create Folder.\r\n\r\nRename this folder Scripts.\r\n\r\nNext let's create a new C# script.\r\n\r\nTo create a new script we have some choices.\r\n\r\nWe can choose Assets - Create\r\nto create our new C# script.\r\n\r\nOr we can use the Create menu in the project view.\r\n\r\nBut what might be more efficient in this case\r\nwould be to select the player game object\r\nand use the Add Component button in the Inspector.\r\n\r\nThe Add Component menu contains the selection\r\nNew Script.\r\n\r\nThis allows us to both create and attach\r\na script in one step.\r\n\r\nFirst let's name this script PlayerController.\r\n\r\nWe can choose the language of the script, which will be C#,\r\nand then click on Create and Add.\r\n\r\nOr simply hit the return or enter key to\r\nconfirm our selection.\r\n\r\nUnity will create, compile and attach this script\r\nto our selected game object.\r\n\r\nWe should note, this way of creating a script\r\nwill create that script asset on the root\r\nor top level of our Project view.\r\n\r\nWe will need to move the asset in to the Scripts directory\r\nin order to maintain an organised Project view.\r\n\r\nIf we select the script in our Project view\r\nwe see a preview of the script asset in the Inspector,\r\nbut this text is not editable.\r\n\r\nLet's open the script.\r\n\r\nWe can do this a number of ways.\r\n\r\nWhen we are inspecting a game object using the script\r\nwe can use the context sensitive gear menu.\r\n\r\nWe can double click on the script asset in the Project view\r\nor we can use the Open button in the Inspector\r\nwhen we have the script selected in our Project view.\r\n\r\nThis will open our script in our preferred script editor.\r\n\r\nFirst let's remove the sample code provided\r\nin the base script.\r\n\r\nNext let's think,\r\nwhat do we want to do with this script?\r\nWe want to check every frame for player input\r\nand then we want to apply that input to the\r\nplayer game object every frame as movement.\r\n\r\nWhere will we check for and apply this input?\r\nWe have two choices.\r\n\r\nUpdate and Fixed Update.\r\n\r\nUpdate is called before rendering a frame\r\nand this is where most of our game code will go.\r\n\r\nFixed Update on the other hand is called just\r\nbefore performing any physics calculations\r\nand this is where our physics code will go.\r\n\r\nWe will be moving our ball by applying forces\r\nto the rigidbody, this is physics.\r\n\r\nSo we will put our code in Fixed Update.\r\n\r\nWhat code to we need to write?\r\nWe know we need input,\r\nbut how do we find out more?\r\nThere is a shortcut in Monodevelop\r\nthat searches the Unity API.\r\n\r\nOn the mac it's command plus single quote,\r\nand on the pc it's control plus single quote.\r\n\r\nSelect the item you want to research,\r\nin our case input,\r\nand hold down the command or control key and\r\ntype the single quote button.\r\n\r\nThis search brings up every reference\r\nin our documentation related to input.\r\n\r\nSelect Input at the top,\r\ninterface in to the input system.\r\n\r\nThis brings up the page on Input.\r\n\r\nThis is the page on the input class.\r\n\r\nWe use this class to read the axis setup in the\r\ninput manager and to access multitouch\r\ntouch and accelerometer data\r\non mobile devices.\r\n\r\nWe read the text on the top of the page to\r\nunderstand how to use the class.\r\n\r\nIn our case, to get input from the player\r\non all platforms, including mobile devices.\r\n\r\nUnder the description is a list of class\r\nvariables and class functions.\r\n\r\nThe class variables hold information\r\nlike the number of touches in touchCount\r\nor a reference to the default gyroscope with gyro.\r\n\r\nThe class functions do something for us.\r\n\r\nIn our code we will be using Input.\r\nGetAxis.\r\n\r\nWhen we find the item we want we click on the link\r\nto bring up a page on the function or the variable.\r\n\r\nLet's look at Input.\r\nGetAxis.\r\n\r\nThis page includes the signature of the function,\r\na description of the function\r\nand code snippets showing how to use it\r\nin Unity's Javascript and C#.\r\n\r\nWe will be using C#.\r\n\r\nFor more information on the input manager\r\nand Input.\r\nGetAxis see the lessons linked below.\r\n\r\nWe will be using Input.\r\nGetAxis in a\r\nvery similar way to the code snippet.\r\n\r\nLet's return to our script and write our code.\r\n\r\nfloat moveHorizontal = Input.\r\nGetAxis (\"horizontal\")\r\nfloat moveVertical = Input.\r\nGetAxis (\"vertical\")\r\nThis grabs the input from our player through the keyboard.\r\n\r\nThe float variables moveHorizontal and moveVertical\r\nrecord the input from the horizontal\r\nand vertical axis, which are controlled by the keys on a keyboard.\r\n\r\nOur player game object uses a rigidbody\r\nand interacts with a physics engine.\r\n\r\nWe will use this input to add forces to the rigidbody\r\nand move the player game object in the scene.\r\n\r\nTo know more about how to apply forces to\r\nthe rigidbody let's check the documentation.\r\n\r\nType Rigidbody in to our script.\r\n\r\nNow select rigidbody and hold down\r\nthe command key on the mac\r\nor the control key on the pc\r\nand type single quote.\r\n\r\nAgain, this brings a page with a search term \"rigidbody\".\r\n\r\nWe want to click on Rigidbody.\r\n\r\nThis brings up the rigidbody page.\r\n\r\nIf we want to apply force to our player game object\r\nwe need to do something.\r\n\r\nSo let's look at the functions available\r\nto the rigidbody class.\r\n\r\nWe read the descriptions until we find\r\nthe one we want, in this case\r\nlet's choose AddForce.\r\n\r\nThis adds a force to the rigidbody\r\nas a result the rigidbody will start moving.\r\n\r\nClick the link and we go to the page on AddForce.\r\n\r\nWe can see the signature of the function\r\nat the top of the page.\r\n\r\nThis signature tells us we need a vector3\r\nand an optional ForceMode to add\r\nforce to our rigidbody.\r\n\r\nWhat is a vector3?\r\nFor more detailed information on vector3\r\nPlease see the information linked below.\r\n\r\nBut in simple terms the vector3\r\nholds 3 decimal values in one container.\r\n\r\nThis makes it easy for us to move around\r\nand use values for things like a force in 3D space,\r\nwhich requires a value for force on\r\neach of the X, Y and Z axis.\r\n\r\nOr to describe a rotation which would also require\r\na value for each of the X, Y and Z axis.\r\n\r\nAll of our documentation pages are linked together.\r\n\r\nIf we were to click on Vector3, we would be taken to the\r\ndocumentation page for vector3.\r\n\r\nThe same is true for ForceMode, MonoBehaviour and RigidBody.\r\n\r\nBelow the description are snippets\r\nthat show us how this function could be used.\r\n\r\nNote the second signature for AddForce below the first.\r\n\r\nThe descriptions are the same.\r\n\r\nBut in this case we can use AddForce with either a vector3\r\nor 3 float values for X, Y and Z.\r\n\r\nThe next concept that we need to cover is\r\nhow to get a hold of, or how to reference\r\ndifferent components on our game object.\r\n\r\nWe are writing a script called PlayerController.\r\n\r\nWhich is attached as a script component\r\nto our Player game object.\r\n\r\nFrom this script we need to AddForce\r\nusing the rigidbody component.\r\n\r\nWe want to access that component from this script.\r\n\r\nThere are several ways that we can do this.\r\n\r\nBut in our case we will cover only one of the main ways\r\nof accessing another component on the same game object.\r\n\r\nWe will create a variable to hold this reference in our script\r\nand we will set this reference in the Start function.\r\n\r\nWe see this here in the code snippet.\r\n\r\npublic Rigidbody rb creates a public variable\r\nwith the type of rigidbody called rb\r\nto hold the reference to the rigidbody we want to access.\r\n\r\nIn Start the reference is set by using the code\r\nGetComponent\r\nThis will find and return a reference to the attached rigidbody,\r\nif there is one.\r\n\r\nAll of the code in the start function is\r\ncalled on the first frame that the script is active.\r\n\r\nThis is often the very first frame of the game.\r\n\r\nFinally in FixedUpdate the attached rigidbody component\r\nis accessed through the variable named rb\r\nwith rb.\r\nAddForce.\r\n\r\nSo in our script we need to write\r\nprivate Rigidbody rb to create the variable to hold the reference.\r\n\r\nAnd in a new start function we need to write\r\nrb=GetComponent\r\nIn FixedUpdate\r\nlet's use the simplest version of Rigidbody.\r\nAddForce.\r\n\r\nOne that simply uses a vector3\r\nand we will leave the ForceMode at default\r\nby omitting it from our code.\r\n\r\nSo in our script we need to type\r\nrb.\r\nAddForce and then some vector3 value.\r\n\r\nNo how do we get our two float values\r\nin to a vector3 value?\r\nLet's create a new vector3 variable called Movement.\r\n\r\nThis will be equal to a new vector3\r\nthat is made up of an X, a Y and a Z.\r\n\r\nThe X, Y, Z values will determine the direction of the force\r\nwe will add to our ball.\r\n\r\nWhat is our X value?\r\nThat would be moveHorizontal.\r\n\r\nWith this our left and right keys will add force\r\nmoving the ball to the left or right.\r\n\r\nWhat is our Y? 0.\r\n\r\nWe don't want to move up at all.\r\n\r\nWhat is our Z value? That would be moveVertical.\r\n\r\nNow we use Movement, a vector3 value,\r\nin rb.\r\nAddForce\r\nas rb.\r\nAddForce(movement).\r\n\r\nLet's save this script and return to Unity.\r\n\r\nWe check for errors in our footer or the console\r\nand there are none.\r\n Good.\r\n\r\nLet's test what we've written.\r\n\r\nHit Play, and by using the keys setup on the input manager\r\nthe ball moves in the scene.\r\n\r\nBut it's very slow.\r\n\r\nThis is too slow to be playable, but the basic concept\r\nworks 100%.\r\n\r\nTo stop testing leave play mode.\r\n\r\nLet's return to our code and create a tool\r\nthat will give us control over the speed of the ball.\r\n\r\nWe need to multiply our movement by some value.\r\n\r\nWe could simply enter that value here on our script\r\nbut if we ever needed to make any tweaks or changes\r\nwe would have to return to our scripting editor\r\nand change the value in the script and then recompile.\r\n\r\nThis takes time.\r\n\r\nThe solution is to create a public variable in our script.\r\n\r\nLet's create a public float\r\ncalled Speed.\r\n\r\nBy creating a public variable in our script\r\nthis variable will show up in the Inspector\r\nas an editable property.\r\n\r\nWhen we use a public variable we can make\r\nall of our changes in the editor.\r\n\r\nWe then multiply Movement by Speed.\r\n\r\nWe now have control over our movement value\r\nfrom inside the editor.\r\n\r\nLet's save these changes and return to Unity.\r\n\r\nWhen we return to the editor we can see our\r\nPlayerController script now has a speed property.\r\n\r\nLet's set this property to 1000.\r\n\r\nNow enter play mode.\r\n\r\nWhoa! Way too fast!\r\nBut changes are fast too.\r\n Exit play mode\r\nand change the value to 500.\r\n\r\nHit Play.\r\n\r\nThat's a little better.\r\n\r\nCongratulations, we can now move our character.\r\n\r\nIn the next assignment we'll talk about how to move the camera.\r\n\r\n# **MOVING THE CAMERA** #\r\n\r\nThe camera doesn't move and from it's current position\r\ncannot see very much.\r\n\r\nWe need to tie the camera to the player game object.\r\n\r\nFirst let's set the position of the camera.\r\n\r\nLet's lift it up by 10 units and tilt it\r\ndown by about 45 degrees.\r\n\r\nNext let's make the camera a child of the\r\nplayer game object.\r\n\r\nThis is a typical third-person setup,\r\nwith the camera as a child of the player.\r\n\r\nWhen we move the player's position\r\nthe camera moves with it.\r\n\r\nWhen the player rotates the camera rotates as well.\r\n\r\nLet's look at this from a position where we\r\ncan see both the player and the camera game object.\r\n\r\nMove the player,\r\nrotate the player,\r\nthe child camera moves with it.\r\n\r\nNow let's reset the player and test.\r\n\r\nWe enter play move, hold down the up arrow to move,\r\nWhoa what's happening here?\r\nOkay, well as the camera is a child of the player's sphere,\r\neven thought the camera is not moving at all\r\nrelative to the player's game object,\r\nthe player game object is rotating like crazy\r\nso the camera's point of view rotates with it.\r\n\r\nLet's exit play mode.\r\n\r\nUnlike a normal third-person game\r\nour player game object is rotating on all 3 axis\r\nnot just 1.\r\n\r\nIn a typical third-person setup\r\nthe camera as a child of the player game object\r\nwill always be in a position relative\r\nto it's immediate parent,\r\nand this position will be the parent's\r\nposition in the game, modified or offset by\r\nany values in the child's transform.\r\n\r\nWe can't have the camera as a child of\r\nthe player, so let's detach it.\r\n\r\nOur offset value will be the difference\r\nbetween the player game object and the camera.\r\n\r\nNow we need to associate the camera with\r\nthe player game object, not as a child\r\nbut with a script.\r\n\r\nUsing the Add Component button choose New Script.\r\n\r\nWe are writing in C#\r\nand name the script CameraController\r\nand then click on Create and Add\r\nor simply hit the return or enter key\r\nto confirm our selection.\r\n\r\nWe should note, this way of creating a script\r\nwill create that script asset on\r\nthe root or top level of our project view.\r\n\r\nFile CameraController in the Scripts folder\r\nand open it for editing.\r\n\r\nWe need 2 variables here.\r\n\r\nA public GameObject reference to the player\r\nand a private vector3 to hold our offset value.\r\n\r\nOffset is private because we can\r\nset that value here in the script.\r\n\r\nFor our offset value we will take the\r\ncurrent transform position.\r\n\r\nand subtract the transform position of the player\r\nto find the difference between the two.\r\n\r\nSo in start we can make offset equal to our\r\ntransform position minus the player's transform position.\r\n\r\nAnd then every frame we set our\r\ntransform position to our player's transform position\r\nplus the offset.\r\n\r\nThis means as we move our player\r\nwith the controls on the keyboard\r\nthat each frame before displaying what the camera can see\r\nthe camera is moved in to a new position\r\naligned with the Player object.\r\n\r\nJust as if it were a child of that object\r\nif it were not rolling around the game board.\r\n\r\nHowever, update is not the best place for this code.\r\n\r\nIt is true that update runs every frame\r\nand in update each frame we can track\r\nthe position of the player's game object\r\nand set the position of the camera.\r\n\r\nHowever, for follow cameras, procedural animation,\r\nand gathering last known states\r\nit's best to use LateUpdate.\r\n\r\nLateUpdate runs every frame, just like update.\r\n\r\nBut it is guaranteed to run after all items\r\nhave been processed in update.\r\n\r\nSo when we set the position of the camera\r\nwe know absolutely that the player has moved for that frame.\r\n\r\nSo let's test this.\r\n Let's save our script\r\nand return to Unity.\r\n\r\nFirst we need to create a reference to the\r\nplayer game object by dragging the player\r\ngame object in to the Player slot\r\nin the camera controller's component.\r\n\r\nEnter play mode\r\nand now we get the behaviour we want.\r\n\r\nThe camera follows the rolling ball\r\nwithout rotating\r\neven as the ball goes over the edge.\r\n\r\nIn the next assignment we will setup the basic\r\nplay area and create and place our\r\nspecial pick-up objects.\r\n\r\n# **SETTING UP THE PLAY AREA** #\r\n\r\nSo let's set up our play field.\r\n\r\nThe play field for our game will be very simple.\r\n\r\nWe will place walls around the edges\r\nto keep our player game object from falling off\r\nand we will create and place a set of collectable\r\nobjects for our player to pick up.\r\n\r\nFirst let's create a new game object\r\nand rename it Walls.\r\n\r\nThis will be an organising parent game object\r\nfor our Wall objects.\r\n\r\nReset this game object to origin.\r\n\r\nNow we will build our walls.\r\n\r\nLet's start by creating a new cube\r\nto be our first wall.\r\n\r\nRename this West Wall.\r\n\r\nReset this game object to origin.\r\n\r\nNow parent West Wall to our Walls game object.\r\n\r\nLet's focus our Scene view camera\r\nto our Wall object.\r\n\r\nWe can do this by typing the F key\r\nwhile the cursor is over the Scene view\r\nor by selecting Edit - Frame Selected.\r\n\r\nWe need to change the size of the cube to fit\r\none side of our play area.\r\n\r\nChange the cube's transform scale of X, Y and Z to\r\n.\r\n5 for thin, 2 for tall and 20.\r\n5 for long.\r\n\r\nNow we can simply push the wall in to place\r\nusing the Translate tool\r\nor we could enter a value in to the transform component.\r\n\r\nIn this case we can set the transform's\r\nposition X value to -10.\r\n\r\nThis places the wall neatly to the edge of our play area.\r\n\r\nTo create the next wall we could\r\nstart with another new cube,\r\nbut then we'd have to rescale this\r\nnew cube before we placed it.\r\n\r\nOur current West Wall is already the perfect size.\r\n\r\nSo let's duplicate the West Wall game object.\r\n\r\nLet's rename it East Wall.\r\n\r\nTo place the wall simply remove the negative sign\r\nand it pops in to place on the east side of our game area.\r\n\r\nNow let's duplicate the east wall\r\nand call it North Wall.\r\n\r\nReset the X position so the north wall\r\nis in the centre of the play area.\r\n\r\nWe now have two choices.\r\n\r\nWe can rotate the wall by 90 degrees,\r\nor, as this is a cuboid,\r\nwe can rescale the wall to 20.\r\n5 in the X and 0.\r\n5 in the Z.\r\n\r\nNow it's scaled correctly for it's orientation\r\nas the north wall.\r\n\r\nWe can drag the wall in to place,\r\nor we can simply use the value of 10\r\nin the transform's position Z field to place it.\r\n\r\nDuplicate North Wall and call it South Wall,\r\nand -10 in the Z axis pops it in to place.\r\n\r\nEnter play mode and test.\r\n\r\nFantastic, the walls work fine.\r\n\r\nRemember to test early and test often,\r\ndon't wait to test.\r\n\r\nLet's exit play mode.\r\n\r\nLet's highlight the Player game object\r\nand set the editor to Local mode,\r\nand try again.\r\n\r\nNote how in Local mode we can see the transform rotate.\r\n\r\nLet's exit play mode.\r\n\r\nIn the next episode we will be creating\r\nour collectable pickup object.\r\n\r\n# **CREATING COLLECTABLE OBJECTS** #\r\n\r\nNext let's create our collectable objects.\r\n\r\nCreate a new cube\r\nand rename it PickUp.\r\n\r\nReset the Pickup's transform to origin.\r\n\r\nFocus the scene view camera on the Pickup object.\r\n\r\nThe Player game object is in the way.\r\n\r\nLet's select the Player game object\r\nand deselect the checkbox in front of the Name field.\r\n\r\nThis is the game object's Active checkbox.\r\n\r\nDeselecting it will deactivate the game object in the scene.\r\n\r\nThis will give us a clear working space\r\nfor our new Pickup object.\r\n\r\nThe cube is buried in the plane, just like our player\r\nsphere was when we started this project.\r\n\r\nThe cube is also a regular shape, 1 by 1 by 1.\r\n\r\nSo let's lift it up by half a unit\r\nand we know it's resting on the plane.\r\n\r\nThis cube will be our Pickup object.\r\n\r\nTo be effective it must attract the attention of the Player.\r\n\r\nSo let's make the cube more attractive.\r\n\r\nWe will start by making it smaller.\r\n\r\nThis will also give it the effect of floating in above the play area.\r\n\r\nBoth will help identify this object as special.\r\n\r\nNot enough however.\r\n\r\nLet's tilt it over.\r\n\r\n45, 45, 45 in each of the axis\r\nof the transform's rotation.\r\n\r\nBetter, but not sexy enough.\r\n\r\nOne thing I feel certainly attracts the attention of a player,\r\nand that is movement.\r\n\r\nSo let's rotate the cube.\r\n\r\nTo do this we need a script.\r\n\r\nWith the Pickup object selected\r\nuse the Add Component button in the Inspector.\r\n\r\nCreate a new script called Rotator.\r\n\r\nClick Create and Add to confirm.\r\n\r\nOrganise the script by placing it in the Scripts folder,\r\nand open it for editing.\r\n\r\nWe want the cube to spin,\r\nand we want to do it with this script.\r\n\r\nLet's remove the sample code we don't need.\r\n\r\nWe will not be using forces, so we can use\r\nupdate rather than fixed update.\r\n\r\nWe have already set the transform rotation\r\nin the transform component to 45, 45, 45\r\nfor the X, Y and Z axis.\r\n\r\nBut these values don't change by themselves.\r\n\r\nWe want to change these values every frame.\r\n\r\nTo make the cube spin we don't want to\r\nset the transform rotation,\r\nbut we want to rotate the transform.\r\n\r\nNext type Transform inside update.\r\n\r\nSelect it and hold down the control key on the PC\r\nor the command key on the Mac\r\nand type single quote.\r\n\r\nAgain, this brings up the page with a search term Transform.\r\n\r\nSelect Transform.\r\n\r\nThis brings up the Transform page in the documentation.\r\n\r\nThere are two main ways to effect the transform.\r\n\r\nThese are Translate and Rotate.\r\n\r\nTranslate moves the game object by it's transform.\r\n\r\nRotate rotates the game object by it's transform.\r\n\r\nWe will use Rotate.\r\n\r\nSo let's click on the link,\r\nand this brings up the page for Transform Rotate.\r\n\r\nNote again the two signatures\r\nand the two possible overrides.\r\n\r\nOne using a vector3 and the other using\r\nthree float values for X, Y and Z.\r\n\r\nBoth overrides have the optional parameter Space.\r\n\r\nWhich we will leave at Default for this lesson.\r\n\r\nAgain we will choose the most simple\r\nform that only uses the vector3 for direction.\r\n\r\nLet's return to our code.\r\n\r\nAfter transform, and make sure transform is written\r\nto begin with a lowercase T,\r\nwrite Rotate (new Vector3 (15, 30, 45)\r\nNow this action also needs to be smooth\r\nand frame rate independent.\r\n\r\nSo we need to multiply the vector3 value\r\nby Time.\r\ndeltaTime.\r\n\r\nSave this script and return to Unity.\r\n\r\nTest by entering play mode, and our Pickup object rotates.\r\n\r\nLet's exit play mode.\r\n\r\nOkay, we have the start of a working Pickup object.\r\n\r\nNext we want to place these around the game area.\r\n\r\nBut before we do this we need to do one important step.\r\n\r\nWe need to make our Pickup object in to a prefab.\r\n\r\nSo remember, a prefab is an asset that contains a template,\r\nor blueprint of a game object or game object family.\r\n\r\nWe create a prefab from an existing game object\r\nor game object family, and once created,\r\nwe can use this prefab in any scene in our current project.\r\n\r\nWith a prefab of our Pickup object\r\nwe will be able to make changes to a single\r\ninstance in our scene,\r\nor to the prefab asset itself,\r\nand all of the Pickup objects in our game\r\nwill be updated with those changes.\r\n\r\nSo first let's create a folder to hold our prefabs.\r\n\r\nWe want this folder on our root, or top level of our project.\r\n\r\nSo select the project view\r\nand make sure that no other item or directory is highlighted.\r\n\r\nAnd then choose Create - Folder\r\nRename this folder Prefabs.\r\n\r\nNow drag the Pickup game object from our hierarchy\r\nand place it in to our Prefabs folder.\r\n\r\nWhen we drag an item from our hierarchy\r\nin to our project view we create a new prefab asset\r\ncontaining a template, or blueprint\r\nof our game object or game object family.\r\n\r\nBefore we spread our collectables around the game area\r\nwe should create a new game object\r\nto hold our Pickups and to help organise our hierarchy.\r\n\r\nLet's create a new game object\r\nand call it Pickups.\r\n\r\nCheck to make sure this parent game object is at origin\r\nand drag our Pickup game object in to it.\r\n\r\nNow we want to spread a number of these Pickup\r\nobjects around the play area.\r\n\r\nFirst, make sure we have the Pickup game object\r\nselected, not the parent.\r\n\r\nNow let's move in to a top-down view\r\nby clicking on the gizmo in to upper-right of our scene view.\r\n\r\nLet's back out a little so we can see the entire game area.\r\n\r\nGrab the Pickup game object,\r\nand it doesn't move in the scene the way we want it to.\r\n\r\nNote how the cube is moving in relation to\r\nit's gizmo, which is tilted over.\r\n\r\nWhat we are seeing is the game object moving in local mode.\r\n\r\nWe really want to move the Pickup game object\r\naligned with the ground.\r\n\r\nChange the editor to Global mode.\r\n\r\nNow see how the orientation of the gizmo changes?\r\nAnd now we can drag our game object around\r\nrelative to the world's global axis.\r\n\r\nSo let's lay down a few of these in the game area.\r\n\r\nTake our first Pickup object\r\nand place it in to the game area, some place convenient.\r\n\r\nI'm going to place mine at the top.\r\n\r\nWith the game object selected, duplicate it.\r\n\r\nThis can be done either by selecting Edit - Duplicate\r\nor by using the hot key combination, this is command-D on the Mac\r\nor control-D on the PC.\r\n\r\nNow we place the second instance of the prefab.\r\n\r\nUsing the hot keys we will create a few more,\r\nplacing them around the play area.\r\n\r\nNote that I'm moving parallel to the ground or the X/Z plane\r\nby selecting the X/Z plane at the centre of the gizmo.\r\n\r\nOkay, that's 12.\r\n\r\nLet's hit play and test.\r\n\r\nExcellent.\r\n\r\nThese Pickup prefabs are working great.\r\n\r\nThe only thing that I want them to do now\r\nis stand out more against the background\r\nwalls and Player game object.\r\n\r\nLet's change their colour/\r\nTo do this we need another material.\r\n\r\nTo make things easy we can simply\r\nselect our existing material and duplicate it.\r\n\r\nLet's rename this new material Pickup.\r\n\r\nWith the material selected in the project view\r\nlet's change the albido colour property to yellow.\r\n\r\nNow we can change the colour of the prefab\r\nby changing the prefab's material.\r\n\r\nWe can do this in two ways.\r\n\r\nWe can change the material on just\r\none instantiated prefab\r\nIf we do this we must remember to\r\nuse the Apply button to apply\r\nthose changes to the prefab asset.\r\n\r\nOtherwise we will only change the material\r\non this single instance.\r\n\r\nThe other way, which is perhaps more simple\r\nis to simply change the material on the\r\nprefab asset directly.\r\n\r\nLet's hit play and test.\r\n\r\nThere, that looks better.\r\n\r\nIn the next assignment we will learn how to\r\npick them up and count them.\r\n\r\n# **COLLECTING THE PICK UP OBJECTS** #\r\n\r\nWe want to be able to pick up our collectable game\r\nobjects when our player game object collides with them.\r\n\r\nTo do this we need to detect our collisions\r\nbetween the player game object and\r\nthe PickUp game objects.\r\n\r\nWe will need to have these collisions\r\ntrigger a new behaviour and we will need to\r\ntest these collisions to make sure we are\r\npicking up the correct objects.\r\n\r\nThe PickUp objects, the player's sphere,\r\nthe ground plane and the walls all have\r\ncolliders that inform us about collisions.\r\n\r\nIf we didn't test our collisions to find out\r\nwhich objects we have collided with\r\nwe could collect the wrong objects.\r\n\r\nWe could collect the floor, or the walls.\r\n\r\nAs a matter of face if we didn't test our collisions\r\non the very first frame of the game we would\r\ncome in contact with the ground plane\r\nand we would collect the ground plane\r\nand then we would fall in to the void of the scene space\r\nand the game would essentially be over.\r\n\r\nFirst, we don't need our player to remain inactive.\r\n\r\nso let's tick the Active checkbox and\r\nbring back our player.\r\n\r\nNext let's select the PlayerController script\r\nand open it for editing.\r\n\r\nJust a note, we could edit this\r\nscript regardless of whether the game\r\nobject is active or not.\r\n\r\nNow that we have the script open,\r\nwhat code are we going to write?\r\nWe could write collider\r\nand then search the documentation using the\r\nhot key combination.\r\n\r\nBut there is a different way that we could do this as well.\r\n\r\nLet's return to Unity and look at the details\r\nof our player game object.\r\n\r\nWhat we are interested in here is the\r\nsphere collider component.\r\n\r\nIn the header of each component on the left\r\nis the component's turndown arrow,\r\nthe icon, the Enable checkbox\r\nif it's available, and the type of the component.\r\n\r\nOn the right is the context sensitive gear gizmo\r\nand an icon of a little book with a question mark.\r\n\r\nNow this is what we need.\r\n\r\nThis is the quick link to the component reference.\r\n\r\nIf we select this icon we are taken\r\nnot to the scripting reference but to the\r\ncomponent reference.\r\n\r\nWe would read this document to find out more\r\nabout how to use this component in the context\r\nof the editor.\r\n\r\nWe, however, want to find out how to\r\nscript to this component's class.\r\n\r\nTo do this we simply switch to scripting\r\nand we are taken to the scripting reference\r\nfor the sphere collider.\r\n\r\nWe want to detect and test our collisions.\r\n\r\nFor this project we are going to use\r\nOnTriggerEnter.\r\n\r\nJust imagine if we were, say, a daring plumber\r\nand we jumped up to collect a perfect arch of coins\r\nand bounced off the very first one as we\r\ncollected it and fell back to the ground.\r\n\r\nNot very elegant.\r\n\r\nThis code will give us the ability to detect\r\nthe contact between our player game object\r\nand our PickUp game objects\r\nwithout actually creating a physical collision.\r\n\r\nThe code example however is not exactly\r\nwhat we're looking for.\r\n\r\nBut that's okay, we can change that.\r\n\r\nFirst, let's copy the code,\r\nand then let's return to our scripting application.\r\n\r\nNow that we're back in scripting let's paste the code.\r\n\r\nAs we have copied this code from a webpage\r\nlet's correct the indents.\r\n\r\nIn this case I'm going to make sure the\r\nindents are tabs and that all of the tabs are\r\ncorrectly aligned.\r\n\r\nNext, let's look at this code.\r\n\r\nWe are using the function OnTriggerEnter.\r\n\r\nOnTriggerEnter will be called by Unity\r\nwhen our player game object first touches\r\na trigger collider.\r\n\r\nWe are given as an argument\r\na reference to the trigger collider that we have touched.\r\n\r\nThis is the collider called Other.\r\n\r\nThis reference gives us a way to get a\r\nhold of the colliders that we touch.\r\n\r\nWith this code, when we touch another trigger\r\ncollider we will destroy the game object\r\nthat the trigger collider is attached to\r\nthrough the reference other.\r\ngameObject.\r\n\r\nBy destroying that game object, the game object,\r\nall of it's components and all of it's\r\nchildren and their components are removed\r\nfrom the scene.\r\n\r\nFor the sake of example in this assignment\r\nwe won't destroy the other game object\r\nwe will deactivate it.\r\n\r\nJust like we deactivated the player object\r\nwhen we were creating our PickUp objects.\r\n\r\nFirst, let's remove the Destroy(other.\r\ngameobject)\r\ncode from the function.\r\n\r\nBut let's paste it down below our script\r\nas a palette to work with.\r\n\r\nHow will we deactivate our PickUp objects?\r\nWell what clues do we have?\r\nWe can address the other collider's game\r\nobject through other.\r\ngameObject.\r\n\r\nWe can see this here in the sample code.\r\n\r\nAnd we want to test the other game object\r\nand if it's a PickUp object we want to deactivate\r\nthat game object.\r\n\r\nSo let's look up GameObject\r\nwith our hot key combination and see what we can find.\r\n\r\nNow we have the page on GameObject.\r\n\r\nThere are two important items here that we want.\r\n\r\nThey are tag,\r\ntag allows us to identify the game object\r\nby comparing the tag value to a string.\r\n\r\nAnd SetActive.\r\n\r\nThis is how we activate or deactivate a game object through code.\r\n\r\nThe last item we need to know about is\r\nCompare Tag.\r\n\r\nCompare Tag allows us to efficiently\r\ncompare the tag of any game object to a sting value.\r\n\r\nLet's open up these three items, each in their own tab.\r\n\r\nTag allows us to identify a game object by a tag value.\r\n\r\nWe must declare our tags in the Tags and Layers Panel before using them.\r\n\r\nIt is possible to test a tag against a string value directly\r\nwith code like\r\nif gameObject.\r\ntag is the same as some string value.\r\n\r\nBut there is a more efficient built-in way to do this,\r\nand that is CompareTag\r\nWith CompareTag we can efficiently\r\ncompare the tag of any game object with a string value.\r\n\r\nLet's copy the sample code and\r\npaste it in to our working palette.\r\n\r\nNow GameObject.\r\nSetActive.\r\n\r\nThis is how we activate or deactivate a game object.\r\n\r\nThis is the code equivalent of clicking\r\nthe Active check box next to the\r\nName field in the Inspector.\r\n\r\nIn our case, just like the code snippet,\r\nwe will call GameObject.\r\nSetActive (false)\r\nto deactivate our PickUp game objects.\r\n\r\nLet's copy this code and returning to our script editor\r\npaste it in to our palette as well.\r\n\r\nI feel we have enough pieces to write our code\r\nso let's write if (other.\r\ngameObject.\r\nCompareTag\r\nwith the string value of PickUp\r\nand we will have to define this tag in Unity later.\r\n\r\nother.\r\ngameObject.\r\nSetActive (false);\r\nNow this code will be called every time\r\nwe touch a trigger collider.\r\n\r\nWe are given a reference to the collider we touch,\r\nwe test it's tag,\r\nand if the tag is the same as the string value\r\nPickUp we will take the other game object\r\nand we will call SetActive (false),\r\nwhich will deactivate that game object.\r\n\r\nNow we don't need this code we've been saving anymore\r\nand keeping it will only confuse the compiler\r\nso we can delete it.\r\n\r\nLet's save this script and return to Unity\r\nand check for errors.\r\n\r\nThe first thing we need to do it set up the tag value\r\nfor the PickUp objects.\r\n\r\nSelect the prefab asset for the PickUp object.\r\n\r\nWhen we look at the tag list\r\nwe don't see any tag called PickUp\r\nso we need to add one.\r\n\r\nSelect Add Tag.\r\n\r\nThis brings up the Tags and Layers Panel.\r\n\r\nHere we can customise tags and layers.\r\n\r\nNote that this list is empty.\r\n\r\nTo create a new custom tag select the + button\r\nto add a new row to the tags list.\r\n\r\nIn the new empty element, in our case tag 0,\r\ntype PickUp, and this is case sensitive\r\nand needs to be exactly the same string\r\nthat we have in our script.\r\n\r\nIf in doubt we can copy and paste\r\nthis string to get the exact value.\r\n\r\nWhen we look back at the prefab asset\r\nnote that the asset is still untagged.\r\n\r\nBy selecting Add Tag we changed our focus\r\nfrom the prefab asset to the Tag Manager\r\nand in the Tag Manager we created our tag.\r\n\r\nNow we need to apply that tag\r\nto the prefab asset.\r\n\r\nSelect the Tag drop down again\r\nand see how we now have PickUp in the list.\r\n\r\nSelect this tag from the list and the asset\r\nis now tagged PickUp.\r\n\r\nAnd with the power of prefabs\r\nall of the instances are now tagged PickUp as well.\r\n\r\nNow let's test our game.\r\n\r\nSave the scene and enter play mode.\r\n\r\nHmm, okay, our tag is set to PickUp\r\nbut we are still bouncing off the PickUp cubes\r\njust like we are bouncing off the walls.\r\n\r\nSo let's exit play mode.\r\n\r\nBefore we discuss why we are bouncing off\r\nthe PickUp cubes rather than picking them up\r\nwe need to have a brief discussion about\r\nUnity's physics system.\r\n\r\nI'm going to enter play mode for this discussion.\r\n\r\nLet's look at one of our cubes and our player.\r\n\r\nAs an aside we can select two or\r\nmore game objects at the same time\r\nand inspect them all.\r\n\r\nWe do this by holding down the command key\r\non the mac or the control key on the PC,\r\nand selecting the game objects.\r\n\r\nWhen we select multiple game objects\r\nnote how the inspector changes to show\r\nthe common components and property\r\nvalues of the selected game objects.\r\n\r\nThe inspector also allows for multi-object editing.\r\n\r\nUsing multi-object editing I'm going to\r\ndisable the mesh renderer on both the\r\nplayer's sphere and the selected cube with a single click.\r\n\r\nThis leaves us with the two green outlines\r\nof the collider volumes for these two objects.\r\n\r\nHow do collisions work in Unity's physics engine?\r\nThe physics engine does not allow two collider\r\nvolumes to overlap.\r\n\r\nWhen the physics engine detects that any two\r\nor more colliders will overlap that frame\r\nthe physics engine will look at the objects and\r\nanalyse their speed and rotation and shape\r\nand calculate a collision.\r\n\r\nOne of the major factors in this calculation\r\nis whether the colliders are static\r\nor dynamic.\r\n\r\nStatic colliders are usually non-moving\r\nparts of your scene, like the walls, the floor,\r\nor the fountain in the courtyard.\r\n\r\nDynamic colliders are things that move\r\nlike the player's sphere or a car.\r\n\r\nWhen calculating a collision the static geometry\r\nwill not be affected by the collision.\r\n\r\nBut the dynamic objects will be.\r\n\r\nIn our case the player's sphere is dynamic,\r\nor moving geometry, and it is bouncing\r\noff the static geometry of the cubes.\r\n\r\nJust as it bounces off the static geometry\r\nof the walls.\r\n\r\nThe physics engine can however allow the\r\npenetration or overlap of collider volumes.\r\n\r\nWhen it does this the physics engine\r\nstill calculates the collider volumes and\r\nkeeps track of the collider overlap.\r\n\r\nBut it doesn't physically act on the overlapping\r\nobjects, it doesn't cause a collision.\r\n\r\nWe do this by making our colliders in to\r\ntriggers, or trigger colliders.\r\n\r\nWhen we make our colliders in to a trigger,\r\nor trigger collider, we can detect\r\nthe contact with that trigger through the\r\nOnTrigger event messages.\r\n\r\nWhen a collider is a trigger you can do\r\nclever things like place a trigger in the middle\r\nof a doorway in, say, an adventure game,\r\nand when the player enters the trigger\r\nthe mini-map updates and a message plays\r\n'you have discovered this room'.\r\n\r\nOr every time your player walks around\r\nthat corner spiders drop from the ceiling\r\nbecause the player has walked through a trigger.\r\n\r\nFor more information on OnCollision and on\r\ntrigger messages see the lessons linked below.\r\n\r\nWe are using OnTriggerEnter in our code\r\nrather than OnCollisionEnter.\r\n\r\nSo we need to change our collider volumes\r\nin to trigger volumes.\r\n\r\nTo do this we must be out of play mode.\r\n\r\nLet's select the prefab asset and look at\r\nthe box collider component.\r\n\r\nHere we select Is Trigger\r\nand again the power of prefabs\r\nall of our PickUp objects are now using trigger colliders.\r\n\r\nLet's save our scene, enter play mode and test.\r\n\r\nAnd as our player enters the trigger\r\nwe pickup the objects.\r\n\r\nExcellent.\r\n\r\nLet's exit play mode.\r\n\r\nEverything looks great.\r\n\r\nWe only have one issue.\r\n\r\nWe have made one small mistake,\r\nand this is related to how Unity\r\noptimises it's physics.\r\n\r\nAs a performance optimisation Unity\r\ncalculates all the volumes\r\nof all the static colliders in a scene\r\nand holds this information in a cache.\r\n\r\nThis makes sense as static colliders\r\nshouldn't move, and this saves recalculating this\r\ninformation every frame.\r\n\r\nWhere we have made our mistake is by rotating our cubes.\r\n\r\nAny time we move, rotate, or scale a static collider\r\nUnity will recalculate all the static colliders again\r\nand update the static collider cache.\r\n\r\nTo recalculate the cache takes resources.\r\n\r\nWe can move, rotate or scale dynamic\r\ncolliders as often as we want and Unity won't\r\nrecache any collider volumes.\r\n\r\nUnity expects us to move colliders.\r\n\r\nWe simply need to indicate to Unity which\r\ncolliders are dynamic before we move them.\r\n\r\nWe do this by using the rigid body component.\r\n\r\nAny game object with a collider\r\nand a rigid body is considered dynamic.\r\n\r\nAny game object with a collider attached\r\nbut no physics rigid body is expected to be static.\r\n\r\nCurrently our PickUp game objects have a\r\nbox collider but no rigid body.\r\n\r\nSo Unity is recalculating our static\r\ncollider cache every frame.\r\n\r\nThe solution is to add a rigid body\r\nto the PickUp objects.\r\n\r\nThis will move the cubes from being static colliders\r\nto being dynamic colliders.\r\n\r\nLet's save and play.\r\n\r\nAnd our cubes fall through the floor.\r\n\r\nGravity pulls them down, and as they are triggers\r\nthey don't collide with the floor.\r\n\r\nLet's exit play mode.\r\n\r\nIf we look at the rigid body component\r\nwe could simply disable Use Gravity,\r\nwhich would prevent the cubes from being pulled downwards.\r\n\r\nThis is only a partial solution however.\r\n\r\nIf we did this, even though our cubes\r\nwould not respond to gravity they would still\r\nrespond to physics forces\r\nThere is a better solution.\r\n\r\nAnd that is to select Is Kinematic.\r\n\r\nWhen we do this we set this rigid body component to be\r\na kinematic rigid body.\r\n\r\nA kinematic rigid body will not react\r\nto physics forces and it can be animated\r\nand moved by it's transform.\r\n\r\nThis is great for everything from objects with colliders\r\nlike elevators and moving platforms,\r\nto objects with triggers, like our collectables\r\nthat need to be animated or moved by their transform.\r\n\r\nFor more information on the rigid body\r\nand Is Kinematic see the lessons linked below.\r\n\r\nLet's save our scene and enter play mode to test.\r\n\r\nNow our behaviour is identical and performant.\r\n\r\nSo, static colliders shouldn't move,\r\nlike walls and floors.\r\n\r\nDynamic colliders can move,\r\nand have a rigid body attached.\r\n\r\nStandard rigid bodies are moved using physics forces.\r\n\r\nKinematic rigid bodies are moved using\r\ntheir transform.\r\n\r\nIn the next assignment we will count our\r\ncollectable object and make a simple UI\r\nto display our score and messages.\r\n\r\n# **DISPLAYING THE SCORE AND TEXT** #\r\n\r\nCounting, displaying text and ending the game.\r\n\r\nWe need a tool to store the value\r\nof our counted collectables.\r\n\r\nAnd another tool to add to that value\r\nas we collect and count them.\r\n\r\nLet's add this tool to our PlayerController script.\r\n\r\nSelect the Player game object and open the\r\nPlayerController script for editing.\r\n\r\nLet's add a private variable to hold our count.\r\n\r\nThis will be an int, as our count will be\r\na whole number, we won't be collecting partial objects,\r\nand let's call it Count.\r\n\r\nSo in our game we will first start\r\nwith a count of 0.\r\n\r\nThen we will need to increment our count value\r\nby 1 when we pick up a new object.\r\n\r\nFirst we need to set our count value to 0.\r\n\r\nAs this variable is private we don't have\r\nany access to it in the Inspector.\r\n\r\nThis variable is only available for use within this script\r\nand as such we will need to set it's starting value\r\nhere in the script.\r\n\r\nThere are several ways we can set the starting value\r\nof Count, but in this assignment we will\r\ndo it in the Start function.\r\n\r\nIn Start set our Count to be equal to 0.\r\n\r\nNext we need to add to Count when we pick up\r\nour collectable game objects.\r\n\r\nWe will pick up our objects in OnTriggerEnter\r\nif the Other game object has the tag Pickup.\r\n\r\nSo this is where we add our counting code.\r\n\r\nAfter setting the other game objects\r\nactive state to False we add our new value of Count\r\nis equal to our old value of Count plus 1.\r\n\r\nThere are other ways to add, count up or increment\r\nthe value when coding for Unity,\r\nbut this one is very easy to understand and\r\nthis is the one that we're going to use in this assignment.\r\n\r\nSave this script and return to Unity.\r\n\r\nNow we can store and increment our count\r\nbut we have no way of displaying it.\r\n\r\nIt would also be good to display a message\r\nwhen the game is over.\r\n\r\nTo display text in this assignment we will\r\nbe using Unity's UI Toolset\r\nto display our text and values.\r\n\r\nFirst let's create a new UI text element\r\nfrom the hierarchy's Create menu.\r\n\r\nLet's look at what we've added to the hierarchy.\r\n\r\nWe seem to have gotten more than we bargained for.\r\n\r\nWe don't just have a UI text element,\r\nbut we've also created a parent\r\ncanvas element and an event systems game object.\r\n\r\nThese are all required by the UI toolset.\r\n\r\nThe single most important thing to know about\r\nthese additional items is that all UI elements must\r\nbe the child of a canvas to behave correctly.\r\n\r\nFor more information on the UI tools,\r\nincluding the canvas and the events system\r\nplease see the information linked below.\r\n\r\nRename the text element CountText.\r\n\r\nSo let's customise this element a bit.\r\n\r\nThe default text is a bit dark.\r\n\r\nLet's make the text colour white,\r\nso it's easier to see.\r\n\r\nThe size and alignment are good.\r\n\r\nAnd let's add some placeholder text\r\nCount Text.\r\n\r\nWe want our text to display in the upper left\r\nof the screen when the game is playing.\r\n\r\nWe can see that the UI text is currently\r\ndisplaying in the centre of the screen in the game view.\r\n\r\nThis is because the text element is anchored\r\nto the centre of it's parent,\r\nwhich is, in this case, the canvas.\r\n\r\nIt is worth noting that the transform component on UI elements\r\nis different from the other game objects in Unity.\r\n\r\nFor UI elements the standard transform has been replaced\r\nwith the rect transform,\r\nwhich takes in to account many specialised features\r\nnecessary for a versatile UI system,\r\nincluding anchoring and positioning.\r\n\r\nFor more information on the rect transform\r\nplease see the information linked below.\r\n\r\nOne of the easiest ways to move the\r\ncount text element in to the upper left\r\nis to anchor it to the upper left corner of\r\nthe canvas, rather than to it's centre.\r\n\r\nTo do this open the Anchors and Presets menu\r\nby clicking on the button displaying the current anchor preset.\r\n\r\nWhen we re-anchor this text element\r\nwe also want to set the pivot\r\nand the position based on the new anchor.\r\n\r\nSo we will hold down both the Shift and the Alt keys\r\nand the select the upper left corner button.\r\n\r\nThat's done it, it's up in the corner.\r\n\r\nBut now it looks budged up against the\r\ncorner of the game view.\r\n\r\nLet's give it some space between the text\r\nand the edges of the screen.\r\n\r\nAs we are anchored to the upper left corner of the canvas\r\nand we have set our pivot to the upper left corner as well\r\nthe easiest way to give the text a little breathing room\r\nis to change the rect transform's\r\nPos X and Pos Y values.\r\n\r\n10 and -10 seems about right,\r\nwith some room around it, yet it's still up and out of the way.\r\n\r\nSo let's wire up the UI text element\r\nto display our count value.\r\n\r\nStart by opening the PlayerController script for editing.\r\n\r\nBefore we can code anything related to any UI elements\r\nwe need to tell our script more about them.\r\n\r\nThe details about the UI toolset\r\nare held in what's called a namespace.\r\n\r\nWe need to use this namespace\r\njust as we are using UnityEngine and System.\r\nCollections.\r\n\r\nSo to do this, at the top of our script write\r\nusing UnityEngine.\r\nUI.\r\n\r\nWith this in place we can now write our code.\r\n\r\nFirst create a new public text variable\r\ncalled countText\r\nto hold a reference to the UI text\r\ncomponent on our UI\r\ntext game object.\r\n\r\nWe need to set the starting value of the\r\nUI text's Text property.\r\n\r\nWe can do this in Start as well.\r\n\r\nWrite countText.\r\nText = \"Count: \"\r\n+ count.\r\nToString, and we need the parenthesis.\r\n\r\nNow this line of code must be written\r\nafter the line setting our count value.\r\n\r\nCount must have some value for us to set a text with.\r\n\r\nNow we also need to update this text property\r\nevery time we pick up a new collectable\r\nso in OnTriggerEnter after we increment our count\r\nvalue let's write again\r\ncountText.\r\nText = 'Count: ' + count.\r\nToString();\r\nHmm, we've now written the same line of code\r\ntwice in the same script.\r\n\r\nThis is generally bad form.\r\n\r\nOne way to make this a little more elegant\r\nis to create a function that does the work in one place\r\nand we simply call this function every time we need it.\r\n\r\nLet's create a new function with void SetCountText\r\nand then an empty set of parenthesis and brackets.\r\n\r\nNow let's move one instance of this line of code\r\nin to the function by cutting and pasting it.\r\n\r\nAnd in it's place let's put a line of code\r\nsimply calling the function.\r\n\r\nFinally let's replace the other line with\r\nthe function call as well.\r\n\r\nExcellent.\r\n Save and swap back to Unity.\r\n\r\nNow we see our PlayerController script has\r\na new text property.\r\n\r\nWe can associate a reference to our Count text\r\nsimply by dragging and dropping the\r\nCountText game object on to the slot.\r\n\r\nUnity will find the text component\r\non the game object and correctly associate the reference.\r\n\r\nNow let's save, enter play mode and test.\r\n\r\nAh-ha! Not only do we collect\r\nthese objects but we count them now.\r\n\r\nLet's exit play mode.\r\n\r\nWe need to display a message when we have\r\ncollected all of the cubes.\r\n\r\nTo do this we will need another UI text object.\r\n\r\nAgain, using the hierarchy's Create menu\r\nmake a new UI text game object.\r\n\r\nRename it Win Text.\r\n\r\nNote how the new UI text element\r\nis automatically added to our canvas.\r\n\r\nAgain, as before, let's customise the values on the component.\r\n\r\nLet's colour the text white so it is easier to see.\r\n\r\nLet's make the text a little larger,\r\nlet's try about 24.\r\n\r\nLastly, let's adjust the alignment to centre and middle.\r\n\r\nAnd again let's add placeholder text\r\nWin Text.\r\n\r\nWe want this text to display in the centre of the game screen\r\nbut up a little so it doesn't cover the player game object.\r\n\r\nTo do this simply adjust the rect transform's\r\nPos Y value as by default this UI text element\r\nis anchored to the centre of the canvas.\r\n\r\nA value of about 75 feels good.\r\n\r\nSave the scene and swap back to our scripting editor.\r\n\r\nWe need to add a reference for this UI text element.\r\n\r\nCreate a new public text variable\r\nand call it winText.\r\n\r\nNow let's set the starting value for the\r\nUI text's text property.\r\n\r\nThis is set to an empty string or two\r\ndouble quote marks with no content.\r\n\r\nThis text property will start empty.\r\n\r\nThen in the SetCountText function let's write\r\nif Count is greater than or equal to 12,\r\nwhich is the total number of objects we have in the\r\ngame to collect, then our winText.\r\nText equals You Win.\r\n\r\nSave this script and return to Unity.\r\n\r\nAgain on our player,\r\nour PlayerController has a new UI text property.\r\n\r\nWe can associate the component\r\nagain by dragging the WinText game object in to the slot.\r\n\r\nSave the scene and play.\r\n\r\nSo we're picking up our game objects,\r\nwe're counting our collectables,\r\nand\r\nwe win!\r\nAnd as we can see when we have collected 12 objects\r\nwe display the 'You Win' text.\r\n\r\nIn the next and last assignment of this series\r\nwe will build the game and deploy it using a standalone player.\r\n\r\n# **BUILDING THE GAME** #\r\n\r\nNow that we've finished our game we need to\r\npresent it to our players.\r\n\r\nOne of the greatest things about Unity is that\r\nonce we have created our game we can deploy\r\nit to many of the current platforms.\r\n\r\nFor more detailed information on building and\r\nbuild targets please see the lesson linked below.\r\n\r\nBefore we build our game we should\r\nsave our scene.\r\n\r\nTo build our game we must first open\r\nthe Build Settings window.\r\n\r\nWe can do this by selecting File - Build Settings\r\nor by using the key combination of\r\nshift plus command or control plus B.\r\n\r\nThis brings up the Build Settings window.\r\n\r\nOur current build target is indicated by the Unity logo.\r\n\r\nThe blue highlight indicates our focus and\r\nshows us on the right hand side the build\r\noptions for the currently selected platform.\r\n\r\nWe want to build a standalone application.\r\n\r\nThis is our current build target.\r\n\r\nPC, Mac and Linux Standalone.\r\n\r\nWe do not need to change our build target.\r\n\r\nIf we did want to change our build target\r\nwe can select the desired platform from the list\r\nand click the Switch Platforms button at the bottom of the window.\r\n\r\nLet's now return our build target to the standalone player.\r\n\r\nOnce we have selected our new build target\r\nwe need to add the scenes we want to build\r\nto the Build Settings window.\r\n\r\nWe can add the current scene by clicking the\r\nAdd Current button.\r\n\r\nOr we can drag and drop any scene from our\r\nproject view in to the field at the top of\r\nthe Build Settings window.\r\n\r\nIt's worth noting that we don't need to\r\ninclude every scene in our project.\r\n\r\nWe only need to include the scenes we\r\nwe want in our game.\r\n\r\nIt is also possible to perform a build\r\nwith no scenes in the build Settings window.\r\n\r\nIf we do this, Unity will simply build our game\r\nusing the current scene we have open for editing.\r\n\r\nNow we are ready to build our game.\r\n\r\nLet's return to the Build Settings window\r\nand click the Build button.\r\n\r\nThis will bring up a dialogue box asking us\r\nto choose a build location.\r\n\r\nI like to associate my build location with\r\nmy project, so I will create a new folder\r\ninside my project called Builds.\r\n\r\nThis folder must be placed only on the\r\nroot of our project alongside the\r\nassets and library folders.\r\n\r\nWith the build folder selected let's name the build\r\nand then click save.\r\n\r\nUnity will now build the application\r\nand save it to our Builds folder\r\nWhen building for the Mac Unity builds a .\r\napp bundle,\r\nwhich contains all of the relevant data and files.\r\n\r\nWhen building for Windows\r\nUnity builds a .\r\nexe file\r\nand a data folder which contains all of the necessary resources.\r\n\r\nTo run the game, simply run the executable application.\r\n\r\nAnd now we are running our game.\r\n\r\nAnd, we win!\r\nSo in these assignments we have learned how to\r\ncreate new game objects, how to position them in the scene,\r\nadd new components to them, write our own custom behaviours\r\nfor them using simple scripting.\r\n\r\nWe've seen how to use lights, cameras,\r\ncolliders, triggers, rigid bodies.\r\n\r\nWe can collect and count objects.\r\n\r\nThough this is a very simple example,\r\nit covers a large set of basic\r\nsubjects important to understanding how to use Unity.\r\n\r\nFor continued learning about Unity check the Learn site\r\nfor more lessons, assignments and projects.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}